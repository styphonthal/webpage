<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Buffalo Sabres — Scores & Goals</title>
<style>
  :root{
    --sabres-navy: #002654;
    --sabres-gold: #FCB514;
    --sabres-white: #f7f9fc;
    --bg-deep: #001631;
  }
  *{box-sizing:border-box; margin:0; padding:0}
  html,body{height:100%; min-height:100vh}
  body{
    color:var(--sabres-white);
    background:
      radial-gradient(1200px 700px at 80% 10%, rgba(252,181,20,.12), transparent 60%),
      radial-gradient(900px 500px at 20% 80%, rgba(0,38,84,.35), transparent 70%),
      var(--bg-deep);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
    padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  .wrap{
    max-width:1200px;
    width:100%;
    margin:0 auto;
    padding:28px clamp(16px, 3vw, 36px);
  }

  /* Team Header */
  .team-header{
    position:relative;
    text-align:center;
    margin-bottom:24px;
    padding:24px 20px;
    background: linear-gradient(180deg, rgba(0,38,84,.65), rgba(0,28,62,.65));
    border: 2px solid rgba(252,181,20,.25);
    border-radius:18px;
    box-shadow: 0 8px 24px rgba(0,0,0,.3);
    overflow:hidden;
  }

  /* Slug images (large, centered on sides) — POP + 3D (1+2) */
  .slug{
    position:absolute;
    top:50%;
    transform:translateY(-50%);
    height:200px;            /* ~4× */
    width:auto;
    opacity:.98;
    pointer-events:none;

    /* (1) depth shadow stack + (2) rim/glow pop */
    filter:
      drop-shadow(0 0 10px rgba(252,181,20,.22))   /* gold glow */
      drop-shadow(0 0 2px  rgba(255,255,255,.18))  /* faint rim */
      drop-shadow(0 24px 24px rgba(0,0,0,.55))     /* main depth */
      drop-shadow(0 10px 10px rgba(0,0,0,.35))     /* mid depth */
      drop-shadow(0 2px  2px  rgba(0,0,0,.25));    /* edge separation */

    will-change: transform, filter;
  }
  .slug-left{ left:18px; }
  .slug-right{ right:18px; transform:translateY(-50%) scaleX(-1); }

  .team-header-inner{
    position:relative;
    z-index:1;
    max-width:760px;
    margin:0 auto;
    padding:0 240px; /* prevent overlap with big slugs */
  }

  /* Header image replacing text */
  .team-title{
    display:block;
    margin:0 auto 10px auto;
    max-width:min(520px, 80vw);
    height:auto;
  }

  .team-stats{
    display:flex;
    justify-content:center;
    gap:32px;
    flex-wrap:wrap;
    margin-top:10px;
  }

  .stat-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:4px;
  }

  .stat-label{
    font-size:.9rem;
    color:#a8c5f5;
    font-weight:600;
    text-transform:uppercase;
    letter-spacing:.5px;
  }

  .stat-value{
    font-size:1.3rem;
    color:var(--sabres-gold);
    font-weight:700;
  }

  .top-scorer{
    margin-top:12px;
    padding-top:12px;
    border-top:1px solid rgba(252,181,20,.2);
    color:#cfe1ff;
    font-size:1.05rem;
  }

  .top-scorer strong{
    color:var(--sabres-gold);
    font-weight:700;
  }

  /* Score header */
  .scorebar{
    display:flex;
    flex-direction:column;
    gap:14px;
    background: linear-gradient(180deg, rgba(0,38,84,.85), rgba(0,28,62,.85));
    border: 2px solid rgba(252,181,20,.35);
    border-radius:18px;
    padding:18px 20px;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
  }

  .score-top{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center;
    gap:16px;
    min-width:0;
  }

  .team{
    display:flex;
    flex-direction:column;
    gap:8px;
    min-width:0;
  }

  .team.away{ align-items:flex-end; text-align:right; }
  .team.home{ align-items:flex-start; text-align:left; }

  .team-name-row{
    display:flex;
    align-items:center;
    gap:12px;
    min-width:0;
  }
  .team.away .team-name-row{ justify-content:flex-end; }
  .team.home .team-name-row{ justify-content:flex-start; }

  .badge{
    width:64px;
    height:64px;
    border-radius:12px;
    background-size:contain;
    background-position:center;
    background-repeat:no-repeat;
    border:2px solid rgba(252,181,20,.3);
    flex-shrink:0;
  }

  .name{
    font-weight:800;
    letter-spacing:.3px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    font-size:1.18rem;
  }

  .team-metrics{
    display:grid;
    gap:4px;
    color:#cfe1ff;
    font-size:.95rem;
    opacity:.95;
  }
  .metric b{ color:#ffe9b3; font-weight:700; }
  .metric span{ color:#cfe1ff; }

  .center-stack{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    min-width:180px;
  }

  .score{
    font-weight:900;
    font-size:2.6rem;
    color:var(--sabres-gold);
    white-space:nowrap;
    line-height:1.05;
  }

  .mid-meta{
    text-align:center;
    color:#cfe1ff;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .state{
    font-weight:800;
    font-size:1.05rem;
  }
  .pill{
    display:inline-block;
    font-size:.9rem;
    padding:5px 12px;
    border-radius:999px;
    background: rgba(252,181,20,.18);
    border:1px solid rgba(252,181,20,.35);
    color:#ffe9b3;
    font-weight:700;
  }
  .muted{
    font-size:.85rem;
    opacity:.75;
  }

  /* Panels */
  .panel{
    margin-top:20px;
    background: linear-gradient(180deg, rgba(0,38,84,.72), rgba(0,28,62,.72));
    border: 1px solid rgba(252,181,20,.28);
    border-radius:16px;
    padding:18px 20px;
  }

  .panel h3{
    margin:0 0 14px 0;
    font-size:1.15rem;
    color:#ffe9b3;
    border-bottom:1px solid rgba(252,181,20,.2);
    padding-bottom:8px;
  }

  .game-summary{
    display:flex;
    flex-direction:column;
    gap:8px;
    font-size:1rem;
  }

  .game-summary strong{
    color:var(--sabres-gold);
  }

  /* Goals list */
  .goals{
    display:grid;
    gap:12px;
    margin-top:14px;
  }

  .goal{
    display:grid;
    grid-template-columns: 110px 1fr;
    gap:14px;
    align-items:start;
    padding:12px 14px;
    border-radius:12px;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(252,181,20,.15);
    transition:all .2s;
  }

  .goal:hover{
    background: rgba(252,181,20,.08);
    border-color:rgba(252,181,20,.3);
  }

  .time{
    font-weight:800;
    color:#ffe3a3;
    font-size:.95rem;
  }

  .goal-details{
    display:flex;
    flex-direction:column;
    gap:4px;
  }

  .who{
    font-weight:800;
    color:var(--sabres-white);
  }

  .team-name{
    color:var(--sabres-gold);
    font-weight:700;
  }

  .assist{
    color:#c6d6f6;
    font-size:.92rem;
    margin-top:2px;
  }

  .assist-player{
    display:inline-block;
    margin-right:8px;
  }

  .sep{
    opacity:.4;
    padding:0 6px;
  }

  .strength{
    color:#a8c5f5;
    font-size:.85rem;
    font-weight:700;
  }

  .loading, .error, .info{
    text-align:center;
    padding:20px;
    color:#c6d6f6;
  }

  .error{
    color:#ff9999;
  }

  .info{
    color:#a8c5f5;
    font-size:.95rem;
    line-height:1.6;
  }

  /* Mobile safeguards */
  @media (max-width: 980px){
    .team-header-inner{ padding:0 200px; }
    .slug{ height:170px; }
  }
  @media (max-width:768px){
    .team-header-inner{ padding:0 96px; }
    .slug{ height:120px; opacity:.65; }
    .slug-left{ left:10px; }
    .slug-right{ right:10px; }

    .score-top{
      grid-template-columns: 1fr;
      gap:14px;
    }

    .team.away, .team.home{
      align-items:center;
      text-align:center;
    }
    .team.away .team-name-row,
    .team.home .team-name-row{
      justify-content:center;
    }

    .center-stack{
      min-width:auto;
    }

    .score{ font-size:2.2rem; }

    .goal{
      grid-template-columns: 96px 1fr;
      gap:10px;
    }
  }

  @media (max-width:480px){
    .team-header-inner{ padding:0 18px; }
    .slug{ display:none; } /* prevent collisions on tiny screens */

    .badge{ width:56px; height:56px; }
    .name{ font-size:1.05rem; }
    .score{ font-size:2rem; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Team Header -->
    <div class="team-header">
      <img class="slug slug-left" src="slug.png" alt="" aria-hidden="true">
      <img class="slug slug-right" src="slug.png" alt="" aria-hidden="true">

      <div class="team-header-inner">
        <!-- Header text replaced with image -->
        <img class="team-title" src="sabres.jpg" alt="Buffalo Sabres">

        <div class="team-stats">
          <div class="stat-item">
            <span class="stat-label">Record</span>
            <span class="stat-value" id="record">0-0-0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Points</span>
            <span class="stat-value" id="points">0</span>
          </div>
        </div>

        <!-- Rename + add leading points -->
        <div class="top-scorer" id="topGoals">
          Loading leading goals...
        </div>
        <div class="top-scorer" id="topPoints" style="margin-top:8px; border-top:none; padding-top:0;">
          Loading leading points...
        </div>
      </div>
    </div>

    <!-- Primary score bar -->
    <div class="scorebar" id="scorebar">
      <div class="score-top">
        <!-- Away -->
        <div class="team away" id="awayTeam">
          <div class="team-name-row">
            <div class="name">Away</div>
            <div class="badge" id="awayBadge"></div>
          </div>

          <!-- Metrics -->
          <div class="team-metrics" id="awayMetrics">
            <div class="metric"><b>SOG</b>: <span id="awaySog">—</span></div>
            <div class="metric"><b>Hits</b>: <span id="awayHits">—</span></div>
            <div class="metric"><b>Blk</b>: <span id="awayBlocks">—</span></div>
            <div class="metric"><b>G</b>: <span id="awayGoalie">—</span></div>
          </div>
        </div>

        <!-- Center -->
        <div class="center-stack">
          <div class="score" id="score">0 — 0</div>
          <div class="mid-meta">
            <div class="state" id="state">Loading…</div>
            <div><span class="pill" id="when"></span></div>
            <div class="muted" id="updated"></div>
          </div>
        </div>

        <!-- Home -->
        <div class="team home" id="homeTeam">
          <div class="team-name-row">
            <div class="badge" id="homeBadge"></div>
            <div class="name">Home</div>
          </div>

          <!-- Metrics -->
          <div class="team-metrics" id="homeMetrics">
            <div class="metric"><b>SOG</b>: <span id="homeSog">—</span></div>
            <div class="metric"><b>Hits</b>: <span id="homeHits">—</span></div>
            <div class="metric"><b>Blk</b>: <span id="homeBlocks">—</span></div>
            <div class="metric"><b>G</b>: <span id="homeGoalie">—</span></div>
          </div>
        </div>
      </div>

      <!-- Live Goals attached to active game box -->
      <div class="panel" id="liveGoalsPanel" style="margin-top:0;">
        <h3>Goals</h3>
        <div class="goals" id="goals"><div class="loading">Loading goals…</div></div>
      </div>
    </div>

    <!-- Most Recent Game (should be the one BEFORE live game when live) -->
    <div class="panel" id="lastGamePanel">
      <h3>Most Recent Game</h3>
      <div id="lastGameBox" class="loading">Loading…</div>
      <div class="goals" id="lastGameGoals"></div>
    </div>

    <!-- Next Game -->
    <div class="panel" id="nextGamePanel">
      <h3>Next Game</h3>
      <div id="nextGameBox" class="loading">Loading…</div>
    </div>
  </div>

<script>
(async function(){
  const SABRES_ABBR = 'BUF';
  const CORS_PROXY = 'https://corsproxy.io/?';

  // Helper functions
  const setTxt = (id, t) => {
    const el = document.getElementById(id);
    if (el) el.textContent = t;
  };

  const setHTML = (id, html) => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  };

  function formatDate(dateStr) {
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        timeZone: 'America/New_York',
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    } catch {
      return dateStr;
    }
  }

  function getTeamLogo(abbr) {
    return `https://assets.nhle.com/logos/nhl/svg/${abbr}_light.svg`;
  }

  function teamLabel(t) {
    return t?.placeName?.default
        || t?.commonName?.default
        || t?.name?.default
        || t?.abbrev
        || '';
  }

  function setUpdatedNow() {
    const el = document.getElementById('updated');
    if (!el) return;
    el.textContent = `Updated ${new Date().toLocaleTimeString('en-US', {
      timeZone: 'America/New_York',
      hour: 'numeric',
      minute: '2-digit',
      second: '2-digit'
    })}`;
  }

  async function fetchJSON(url) {
    const proxiedUrl = CORS_PROXY + encodeURIComponent(url);
    const response = await fetch(proxiedUrl, { cache: 'no-store' });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  }

  // (Requested) Save% display as .XXX
  function formatSavePct(v) {
    if (v == null || v === '' || !Number.isFinite(Number(v))) return '—';
    let x = Number(v);
    // accept 0.923, 92.3, 923
    if (x > 1 && x <= 100) x = x / 100;
    if (x > 100) x = x / 1000;
    x = Math.max(0, Math.min(0.999, x));
    const n = Math.round(x * 1000);
    return '.' + String(n).padStart(3, '0');
  }

  // Get team standings and stats
  async function getTeamStats() {
    try {
      const url = `https://api-web.nhle.com/v1/standings/now`;
      const data = await fetchJSON(url);

      let sabres = null;
      for (const standing of data.standings || []) {
        if (standing.teamAbbrev?.default === SABRES_ABBR) {
          sabres = standing;
          break;
        }
      }

      if (!sabres) return { wins: 0, losses: 0, otLosses: 0, points: 0 };

      return {
        wins: sabres.wins || 0,
        losses: sabres.losses || 0,
        otLosses: sabres.otLosses || 0,
        points: sabres.points || 0
      };
    } catch {
      return null;
    }
  }

  // Get roster and find leaders (goals + points)
  async function getLeaders() {
    try {
      const url = `https://api-web.nhle.com/v1/club-stats/${SABRES_ABBR}/now`;
      const data = await fetchJSON(url);

      const skaters = data.skaters || [];
      if (!skaters.length) return null;

      const bestGoals = skaters.reduce((best, p) => (p.goals||0) > (best.goals||0) ? p : best, skaters[0]);
      const bestPoints = skaters.reduce((best, p) => (p.points||0) > (best.points||0) ? p : best, skaters[0]);

      const name = (p) => `${p.firstName?.default || ''} ${p.lastName?.default || ''}`.trim();

      return {
        goals: { name: name(bestGoals), val: bestGoals.goals || 0 },
        points: { name: name(bestPoints), val: bestPoints.points || 0 }
      };
    } catch {
      return null;
    }
  }

  // Schedule: broaden "live-ish" detection so intermission doesn't break your selection
  async function getSchedule() {
    const now = new Date();
    const formatAPIDate = (d) => d.toISOString().split('T')[0];

    const url = `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${formatAPIDate(now)}`;
    const data = await fetchJSON(url);

    const prevWeek = new Date(now);
    prevWeek.setDate(prevWeek.getDate() - 7);
    const prevUrl = `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${formatAPIDate(prevWeek)}`;
    const prevData = await fetchJSON(prevUrl);

    const allGames = [...(prevData.games || []), ...(data.games || [])];

    const LIVE_STATES = new Set(['LIVE','CRIT','CRITICAL','IN_PROGRESS','INPROGRESS','PROG','STARTED']);
    const liveGame = allGames.find(g => LIVE_STATES.has(g.gameState));

    const completed = allGames
      .filter(g => (g.gameState === 'OFF' || g.gameState === 'FINAL'))
      .sort((a, b) => new Date(b.startTimeUTC) - new Date(a.startTimeUTC));

    // last completed excluding live game id
    const lastGame = completed.find(g => g.id !== liveGame?.id) || completed[0] || null;

    // "previous game" used for "Most Recent Game" panel when live:
    // If live exists, show the most recent completed game (already lastGame).
    // If not live, lastGame is also the most recent completed.
    const mostRecentCompleted = lastGame;

    const nextGame = allGames
      .filter(g => g.gameState === 'FUT' || g.gameState === 'PRE')
      .sort((a, b) => new Date(a.startTimeUTC) - new Date(b.startTimeUTC))[0] || null;

    return { liveGame, mostRecentCompleted, nextGame, games: allGames };
  }

  // Get game details with cache buster
  async function getGameDetails(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/play-by-play?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  // Boxscore (can be missing some totals depending on timing)
  async function getGameBoxscore(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/boxscore?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  // Landing tends to have team totals (SOG/Hits/Blocks) more reliably than play-by-play
  async function getGameLanding(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/landing?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  function safeStr(x) {
    if (x == null) return '—';
    const s = String(x).trim();
    return s ? s : '—';
  }

  function goalieLabelFromAny(g) {
    if (!g) return '—';
    const ln = g.lastName?.default || g.lastName || '';
    const fn = g.firstName?.default || g.firstName || '';
    const sv = g.savePctg ?? g.savePercentage ?? g.savePct ?? g.svPct ?? g.savePctgDecimal ?? null;
    const pct = formatSavePct(sv);
    const name = ln || (fn ? fn : (g.name?.default || g.name || 'Goalie'));
    return `${name} (${pct})`;
  }

  function pickGoalieFromLists(t) {
    if (!t) return null;
    const candidates =
      t?.goalies ||
      t?.goalieStats ||
      t?.goalie ||
      null;

    if (Array.isArray(candidates) && candidates.length) {
      // pick likely starter by TOI / shots faced
      const sorted = candidates.slice().sort((a,b) => {
        const toiA = a.timeOnIce ?? a.toi ?? 0;
        const toiB = b.timeOnIce ?? b.toi ?? 0;
        const sfA = a.shotsAgainst ?? a.shotsFaced ?? 0;
        const sfB = b.shotsAgainst ?? b.shotsFaced ?? 0;
        return (toiB - toiA) || (sfB - sfA);
      });
      return sorted[0] || candidates[0];
    }
    return null;
  }

  // Extract team totals (SOG/Hits/Blocks/Goalie) from landing/boxscore with multiple fallbacks
  function extractTeamTotals(side, landing, boxscore) {
    const out = { sog: null, hits: null, blocks: null, goalie: null };

    // LANDING: common shapes (varies)
    try {
      const tg =
        landing?.summary?.teamGameStats ||
        landing?.teamGameStats ||
        landing?.teamGameStatistics ||
        null;

      const t =
        tg?.[side] ||
        (Array.isArray(tg) ? tg.find(x => x?.homeAway === side) : null) ||
        null;

      if (t) {
        out.sog = t.sog ?? t.shotsOnGoal ?? t.shots ?? out.sog;
        out.hits = t.hits ?? out.hits;
        out.blocks = t.blockedShots ?? t.blocks ?? out.blocks;
      }

      // goalie info sometimes exists elsewhere in landing
      const goalieCandidate =
        (side === 'away' ? landing?.awayTeam : landing?.homeTeam) ||
        null;
      out.goalie = pickGoalieFromLists(goalieCandidate) || out.goalie;
    } catch {}

    // BOXSCORE fallback
    try {
      const tb = (side === 'away')
        ? (boxscore?.awayTeam || boxscore?.away)
        : (boxscore?.homeTeam || boxscore?.home);

      if (tb) {
        out.sog = tb.shotsOnGoal ?? tb.sog ?? tb.teamStats?.shotsOnGoal ?? out.sog;
        out.hits = tb.hits ?? tb.teamStats?.hits ?? out.hits;
        out.blocks = tb.blockedShots ?? tb.blocked ?? tb.teamStats?.blockedShots ?? out.blocks;

        out.goalie = pickGoalieFromLists(tb) || out.goalie;
      }

      // playerByGameStats.goalies fallback
      const pgs = boxscore?.playerByGameStats;
      const gList = (side === 'away') ? pgs?.awayTeam?.goalies : pgs?.homeTeam?.goalies;
      if (!out.goalie && Array.isArray(gList) && gList.length) out.goalie = gList[0];
    } catch {}

    return out;
  }

  function applyTeamMetrics(side, landing, boxscore) {
    const t = extractTeamTotals(side, landing, boxscore);
    setTxt(side + 'Sog', safeStr(t.sog));
    setTxt(side + 'Hits', safeStr(t.hits));
    setTxt(side + 'Blocks', safeStr(t.blocks));
    setTxt(side + 'Goalie', goalieLabelFromAny(t.goalie));
  }

  // Render the main scorebar
  function renderScorebar(game, details, landing, boxscore) {
    if (!game) {
      setTxt('state', 'No game data');
      setTxt('when', '—');
      return;
    }

    const away = details?.awayTeam || game.awayTeam;
    const home = details?.homeTeam || game.homeTeam;

    document.querySelector('#awayTeam .name').textContent = teamLabel(away);
    document.querySelector('#homeTeam .name').textContent = teamLabel(home);

    const awayAbbrev = away.abbrev || game.awayTeam?.abbrev;
    const homeAbbrev = home.abbrev || game.homeTeam?.abbrev;

    document.getElementById('awayBadge').style.backgroundImage = `url('${getTeamLogo(awayAbbrev)}')`;
    document.getElementById('homeBadge').style.backgroundImage = `url('${getTeamLogo(homeAbbrev)}')`;

    const awayScore = details?.awayTeam?.score ?? game.awayTeam?.score ?? 0;
    const homeScore = details?.homeTeam?.score ?? game.homeTeam?.score ?? 0;
    setTxt('score', `${awayScore} — ${homeScore}`);

    const gameState = details?.gameState || game.gameState;
    const isLive = ['LIVE', 'CRIT', 'CRITICAL'].includes(gameState);

    let status = 'Final';
    if (isLive) {
      status = 'LIVE';
      if (details?.periodDescriptor) {
        const period = details.periodDescriptor.number;
        const periodType = details.periodDescriptor.periodType;
        if (periodType === 'OT') status = 'OVERTIME';
        else if (periodType === 'SO') status = 'SHOOTOUT';
        else status = `${period}${period === 1 ? 'st' : period === 2 ? 'nd' : period === 3 ? 'rd' : 'th'} Period`;
      }
      if (details?.clock?.inIntermission) status = 'Intermission';
    } else if (['FUT', 'PRE'].includes(gameState)) status = 'Scheduled';
    else if (['FINAL', 'OFF'].includes(gameState)) status = 'Final';

    setTxt('state', status);

    // time/when
    let when = '';
    if (isLive) {
      if (details?.clock?.inIntermission) {
        const ir =
          details.clock.intermissionTimeRemaining ||
          details.clock.intermissionRemaining ||
          details.clock.intermissionTimeRemainingSeconds;

        if (typeof ir === 'string' && ir.trim()) when = `INT ${ir}`;
        else if (typeof ir === 'number' && Number.isFinite(ir)) {
          const mm = Math.floor(ir / 60);
          const ss = String(ir % 60).padStart(2, '0');
          when = `INT ${mm}:${ss}`;
        } else {
          when = 'Intermission';
        }
      } else {
        when = details?.clock?.timeRemaining || '';
      }
    } else {
      when = formatDate(game.startTimeUTC);
    }
    setTxt('when', when || '—');

    // metrics (prefer landing, then boxscore)
    applyTeamMetrics('away', landing, boxscore);
    applyTeamMetrics('home', landing, boxscore);
  }

  function buildPlayerMap(details) {
    const playerMap = new Map();
    const roster = details?.rosterSpots || [];
    for (const p of roster) {
      if (!p?.playerId) continue;
      const nm = `${p.firstName?.default || ''} ${p.lastName?.default || ''}`.trim();
      playerMap.set(p.playerId, nm);
    }
    return playerMap;
  }

  function timeToSec(t) {
    if (!t) return 0;
    const parts = String(t).split(':');
    const mm = parseInt(parts[0] || '0', 10);
    const ss = parseInt(parts[1] || '0', 10);
    return (mm * 60) + ss;
  }

  // Render goals into a specific container, newest-first if requested
  function renderGoals(details, containerId, newestFirst = true) {
    const goalsEl = document.getElementById(containerId);
    if (!goalsEl) return;

    if (!details) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const plays = details.plays || details.gameEvents || [];
    if (!plays || !plays.length) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const playerMap = buildPlayerMap(details);

    let goals = plays
      .filter(p => p.typeDescKey === 'goal' || p.typeCode === 'GOAL')
      .filter(p => p.periodDescriptor?.periodType !== 'SO'); // exclude shootout

    if (!goals.length) {
      goalsEl.innerHTML = '<div class="loading">No goals scored yet</div>';
      return;
    }

    // sort by period then time; then reverse for newest-first
    goals.sort((a,b) => {
      const pd = (a.periodDescriptor?.number || 0) - (b.periodDescriptor?.number || 0);
      if (pd !== 0) return pd;
      return timeToSec(a.timeInPeriod) - timeToSec(b.timeInPeriod);
    });
    if (newestFirst) goals.reverse();

    let html = '';
    for (const goal of goals) {
      const period = goal.periodDescriptor?.number || '';
      const time = goal.timeInPeriod || '';
      const teamId = goal.details?.eventOwnerTeamId;

      const teamInfo = (details.homeTeam?.id === teamId) ? details.homeTeam : details.awayTeam;
      const tName = teamLabel(teamInfo);

      let scorerName = 'Unknown';
      let goalNumber = '';

      if (goal.details) {
        const scorerId = goal.details.scoringPlayerId || goal.details.playerId;
        if (scorerId && playerMap.has(scorerId)) scorerName = playerMap.get(scorerId);
        else if (goal.details.scoringPlayer) scorerName = goal.details.scoringPlayer;
        if (goal.details.scoringPlayerTotal) goalNumber = ` (${goal.details.scoringPlayerTotal})`;
      }

      const assists = [];
      if (goal.details) {
        const a1 = goal.details.assist1PlayerId;
        if (a1 && playerMap.has(a1)) {
          assists.push(`${playerMap.get(a1)}${goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : ''}`);
        } else if (goal.details.assist1Player) {
          assists.push(`${goal.details.assist1Player}${goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : ''}`);
        }

        const a2 = goal.details.assist2PlayerId;
        if (a2 && playerMap.has(a2)) {
          assists.push(`${playerMap.get(a2)}${goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : ''}`);
        } else if (goal.details.assist2Player) {
          assists.push(`${goal.details.assist2Player}${goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : ''}`);
        }
      }

      const strength = goal.details?.strength || 'ev';
      const situation = goal.details?.situationCode || '';

      html += `
        <div class="goal">
          <div class="time">P${period}<br>${time}</div>
          <div class="goal-details">
            <div>
              <span class="team-name">${tName}</span>
              <span class="sep">—</span>
              <span class="who">${scorerName}${goalNumber}</span>
            </div>
            <div class="strength">${String(strength).toUpperCase()}${situation ? ` (${situation})` : ''}</div>
            ${assists.length ? `<div class="assist">Assists: ${assists.map(a => `<span class="assist-player">${a}</span>`).join('')}</div>` : ''}
          </div>
        </div>
      `;
    }

    goalsEl.innerHTML = html;
  }

  function renderLastGame(game) {
    const el = document.getElementById('lastGameBox');
    if (!game) {
      el.innerHTML = '<div class="loading">No previous game data</div>';
      return;
    }

    const away = game.awayTeam;
    const home = game.homeTeam;
    const when = formatDate(game.startTimeUTC);

    el.innerHTML = `
      <div class="game-summary">
        <div><strong>${teamLabel(away)}</strong> at <strong>${teamLabel(home)}</strong></div>
        <div>Final: ${away.score || 0} — ${home.score || 0}</div>
        <div>${when}</div>
      </div>
    `;
  }

  function renderNextGame(game) {
    const el = document.getElementById('nextGameBox');
    if (!game) {
      el.innerHTML = '<div class="loading">No upcoming game scheduled</div>';
      return;
    }

    const away = game.awayTeam;
    const home = game.homeTeam;
    const when = formatDate(game.startTimeUTC);

    el.innerHTML = `
      <div class="game-summary">
        <div><strong>${teamLabel(away)}</strong> at <strong>${teamLabel(home)}</strong></div>
        <div>${when}</div>
      </div>
    `;
  }

  function setGoalsVisibility(show) {
    const liveGoalsPanel = document.getElementById('liveGoalsPanel');
    if (!liveGoalsPanel) return;
    liveGoalsPanel.style.display = show ? '' : 'none';
  }

  // Main execution
  try {
    const schedule = await getSchedule();

    // team header
    const teamStats = await getTeamStats().catch(()=>null);
    if (teamStats) {
      setTxt('record', `${teamStats.wins}-${teamStats.losses}-${teamStats.otLosses}`);
      setTxt('points', String(teamStats.points));
    } else {
      setTxt('record', '—');
      setTxt('points', '—');
    }

    const leaders = await getLeaders().catch(()=>null);
    if (leaders) {
      setHTML('topGoals', `Leading goals: <strong>${leaders.goals.name}</strong>, ${leaders.goals.val}`);
      setHTML('topPoints', `Leading points: <strong>${leaders.points.name}</strong>, ${leaders.points.val}`);
    } else {
      setHTML('topGoals', 'Leading goals unavailable');
      setHTML('topPoints', 'Leading points unavailable');
    }

    // primary game selection
    const primaryGame = schedule.liveGame || schedule.mostRecentCompleted;
    const isLive = !!schedule.liveGame;

    // Next game always
    renderNextGame(schedule.nextGame);

    // Most Recent Game panel should be the completed game BEFORE live (when live).
    // schedule.mostRecentCompleted already excludes live id.
    renderLastGame(schedule.mostRecentCompleted);

    // If no primary, hide live goals panel and stop.
    if (!primaryGame) {
      setGoalsVisibility(false);
      setTxt('state', 'No recent game');
      setTxt('score', '— — —');
      setTxt('when', '—');
      setTxt('updated', '');
      setHTML('goals', '<div class="info">No recent games found. Check back during the hockey season!</div>');
      setHTML('lastGameGoals', '');
      return;
    }

    setGoalsVisibility(true);

    // Load details + landing (preferred totals) + boxscore (fallback)
    const [details, landing, boxscore] = await Promise.all([
      getGameDetails(primaryGame.id),
      getGameLanding(primaryGame.id).catch(()=>null),
      getGameBoxscore(primaryGame.id).catch(()=>null)
    ]);

    renderScorebar(primaryGame, details, landing, boxscore);
    renderGoals(details, 'goals', true); // newest-first for active game
    setUpdatedNow();

    // Most recent completed game: show scorers/assists if finished and not the same as primary when live
    const recent = schedule.mostRecentCompleted;
    if (recent?.id) {
      try {
        const recentDetails = await getGameDetails(recent.id);
        document.getElementById('lastGameGoals').innerHTML = '<h3 style="margin-top:18px;">Scoring</h3>';
        const lg = document.createElement('div');
        lg.className = 'goals';
        lg.id = 'lastGameGoalsList';
        document.getElementById('lastGameGoals').appendChild(lg);
        renderGoals(recentDetails, 'lastGameGoalsList', true);
      } catch {
        setHTML('lastGameGoals', '');
      }
    }

    // If live: auto-refresh
    if (isLive) {
      const gameId = primaryGame.id;

      const refreshInterval = setInterval(async () => {
        try {
          const [updatedDetails, updatedLanding, updatedBox] = await Promise.all([
            getGameDetails(gameId),
            getGameLanding(gameId).catch(()=>null),
            getGameBoxscore(gameId).catch(()=>null)
          ]);

          const gameState = updatedDetails?.gameState;
          renderScorebar(primaryGame, updatedDetails, updatedLanding, updatedBox);
          renderGoals(updatedDetails, 'goals', true);
          setUpdatedNow();

          if (['FINAL', 'OFF'].includes(gameState)) {
            clearInterval(refreshInterval);
            setTimeout(() => location.reload(), 2000);
          }
        } catch (e) {
          console.error('Refresh error:', e);
        }
      }, 15000);
    }

  } catch (error) {
    console.error('Error loading data:', error);
    setTxt('state', 'Error loading data');
    setTxt('when', '—');
    setTxt('updated', '');
    setHTML('goals', `<div class="error">Unable to load NHL data. This widget uses a CORS proxy which may be rate-limited.</div>`);
    setHTML('lastGameBox', '<div class="error">—</div>');
    setHTML('nextGameBox', '<div class="error">—</div>');
    setHTML('lastGameGoals', '');
  }
})();
</script>

</body>
</html>
