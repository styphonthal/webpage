<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NHL Panel (PBP + Boxscore)</title>
  <style>
    /* Minimal styling; swap in your existing CSS if you want the full theme */
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0e0f13; color:#fff; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    .row { display:flex; gap:12px; flex-wrap: wrap; }
    .card { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; flex: 1 1 280px; }
    .title { font-weight: 800; font-size: 18px; margin-bottom: 8px; }
    .muted { color: rgba(255,255,255,0.65); font-size: 13px; }
    .big { font-size: 44px; font-weight: 900; line-height: 1; }
    .sep { opacity: 0.35; padding: 0 10px; font-weight: 600; }
    .statgrid { display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 10px; }
    .stat { text-align:center; padding: 10px; border-radius: 10px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); }
    .stat .k { font-size: 12px; color: rgba(255,255,255,0.6); font-weight: 700; letter-spacing: 0.4px; text-transform: uppercase; }
    .stat .v { font-size: 20px; font-weight: 900; margin-top: 4px; }
    .plays { max-height: 260px; overflow:auto; display:flex; flex-direction:column; gap:8px; }
    .play { padding: 10px; border-radius: 10px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); }
    .play .t { font-size: 12px; color: rgba(255,255,255,0.65); font-weight: 700; }
    .play .d { font-size: 14px; font-weight: 650; margin-top: 4px; }
    .btn { cursor:pointer; background: transparent; border: 1px solid rgba(255,255,255,0.25); color:#fff; padding:6px 10px; border-radius: 10px; font-weight: 700; }
    /* Debug panel */
    #nhlDebugLog { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); width: 420px; max-height: 420px;
      background: rgba(0,0,0,0.92); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 11px; overflow:auto; z-index: 9999;
      box-shadow: 0 12px 40px rgba(0,0,0,0.6); backdrop-filter: blur(10px); }
    #nhlDebugLog .hdr { display:flex; justify-content: space-between; align-items:center; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.15); }
    #nhlDebugLog .hdr b { font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <div class="card" style="flex:1 1 100%;">
        <div style="display:flex; justify-content: space-between; align-items:center; gap:12px;">
          <div>
            <div class="title" id="hdrTitle">NHL Panel</div>
            <div class="muted" id="hdrSub">Loading‚Ä¶</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <button class="btn" id="refreshNow">Refresh</button>
            <select id="teamSelect" class="btn" style="padding: 6px 10px;">
              <!-- abbreviations -->
              <option value="BUF" selected>BUF</option>
              <option value="TOR">TOR</option><option value="MTL">MTL</option><option value="BOS">BOS</option>
              <option value="NYR">NYR</option><option value="NYI">NYI</option><option value="NJD">NJD</option>
              <option value="PIT">PIT</option><option value="PHI">PHI</option><option value="WSH">WSH</option>
              <option value="TBL">TBL</option><option value="FLA">FLA</option><option value="CAR">CAR</option>
              <option value="DET">DET</option><option value="OTT">OTT</option><option value="CBJ">CBJ</option>
              <option value="CHI">CHI</option><option value="STL">STL</option><option value="NSH">NSH</option>
              <option value="DAL">DAL</option><option value="COL">COL</option><option value="MIN">MIN</option>
              <option value="WPG">WPG</option><option value="EDM">EDM</option><option value="CGY">CGY</option>
              <option value="VAN">VAN</option><option value="SEA">SEA</option><option value="VGK">VGK</option>
              <option value="LAK">LAK</option><option value="SJS">SJS</option><option value="ANA">ANA</option>
              <option value="UTA">UTA</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <div class="title">Last Game</div>
        <div class="muted" id="lastGameLine">‚Äî</div>
      </div>
      <div class="card">
        <div class="title">Next Game</div>
        <div class="muted" id="nextGameLine">‚Äî</div>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:1 1 100%;">
        <div class="title">Score</div>
        <div style="display:flex; align-items:baseline; gap:10px;">
          <div class="big" id="scoreLeft">0</div>
          <div class="sep">‚Äî</div>
          <div class="big" id="scoreRight">0</div>
        </div>
        <div class="muted" id="scoreMeta">‚Äî</div>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:1 1 100%;">
        <div class="title">Team totals (Boxscore)</div>
        <div class="statgrid">
          <div class="stat"><div class="k">Shots</div><div class="v" id="stShots">‚Äî</div></div>
          <div class="stat"><div class="k">Faceoffs</div><div class="v" id="stFO">‚Äî</div></div>
          <div class="stat"><div class="k">Hits</div><div class="v" id="stHits">‚Äî</div></div>
          <div class="stat"><div class="k">Blocks</div><div class="v" id="stBlocks">‚Äî</div></div>
        </div>
        <div class="muted" id="statsNote" style="margin-top:10px;">Uses boxscore team totals. PBP used only for plays/goals/penalties/situation.</div>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:1 1 100%;">
        <div class="title">Recent plays (PBP)</div>
        <div class="plays" id="playsBox"></div>
      </div>
    </div>
  </div>

  <script>
    // ============================================================
    // CONFIG
    // ============================================================
    const REFRESH_MS_LIVE = 15000;
    const REFRESH_MS_IDLE = 120000;

    // ============================================================
    // LOGGING (kept structure, standalone)
    // ============================================================
    let logMessages = [];
    const MAX_LOG_MESSAGES = 15;

    function addLog(message, type = "info") {
      const timestamp = new Date().toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      logMessages.unshift({ time: timestamp, message, type });
      if (logMessages.length > MAX_LOG_MESSAGES) logMessages = logMessages.slice(0, MAX_LOG_MESSAGES);
      updateLogPanel();
      console.log(`[NHL ${timestamp}]`, message);
    }

    function updateLogPanel() {
      let logPanel = document.getElementById("nhlDebugLog");
      if (!logPanel) {
        logPanel = document.createElement("div");
        logPanel.id = "nhlDebugLog";
        logPanel.innerHTML = `
          <div class="hdr">
            <b>üèí Debug Log</b>
            <div style="display:flex; gap:6px;">
              <button class="btn" id="clearLogBtn" style="padding:4px 8px;">Clear</button>
              <button class="btn" id="toggleLogBtn" style="padding:4px 8px;">‚àí</button>
            </div>
          </div>
          <div id="logMessages"></div>
        `;
        document.body.appendChild(logPanel);

        document.getElementById("clearLogBtn").addEventListener("click", () => {
          logMessages = [];
          updateLogPanel();
        });

        let minimized = false;
        document.getElementById("toggleLogBtn").addEventListener("click", (e) => {
          minimized = !minimized;
          document.getElementById("logMessages").style.display = minimized ? "none" : "block";
          e.target.textContent = minimized ? "+" : "‚àí";
          logPanel.style.maxHeight = minimized ? "46px" : "420px";
        });
      }

      const box = document.getElementById("logMessages");
      if (!box) return;

      const typeColors = { info:"#00bfff", success:"#00ff88", warning:"#ffaa00", error:"#ff3b30" };
      box.innerHTML = logMessages.map(l => `
        <div style="margin-bottom:6px; padding:6px; background: rgba(255,255,255,0.03); border-radius:8px; border-left:3px solid ${typeColors[l.type] || typeColors.info};">
          <div style="color: rgba(255,255,255,0.55); font-size:10px;">${l.time}</div>
          <div style="color:${typeColors[l.type] || typeColors.info};">${l.message}</div>
        </div>
      `).join("");
    }

    // ============================================================
    // FETCH HELPERS
    // ============================================================
    async function fetchJson(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status}: ${url}`);
      return r.json();
    }

    // ============================================================
    // SCHEDULE -> find last/next + current (live/pre)
    // ============================================================
    async function fetchScheduleNow() {
      return fetchJson("https://api-web.nhle.com/v1/schedule/now");
    }

    function parseDateMs(d) {
      const t = Date.parse(d);
      return Number.isFinite(t) ? t : null;
    }

    function buildFullName(team) {
      const place = team?.placeName?.default || "";
      const common = team?.commonName?.default || "";
      return `${place} ${common}`.trim();
    }

    function isTeamInGame(game, abbr) {
      const h = (game?.homeTeam?.abbrev || "").toUpperCase();
      const a = (game?.awayTeam?.abbrev || "").toUpperCase();
      return (h === abbr.toUpperCase() || a === abbr.toUpperCase());
    }

    function extractGames(scheduleNow) {
      const out = [];
      for (const week of (scheduleNow?.gameWeek || [])) {
        for (const g of (week?.games || [])) out.push(g);
      }
      return out;
    }

    function findRelevantGames(scheduleNow, teamAbbr) {
      const games = extractGames(scheduleNow).filter(g => isTeamInGame(g, teamAbbr));
      const now = Date.now();

      // pick last finished (POST / FINAL-ish) and next future (PRE/FUT)
      let last = null;
      let next = null;
      let current = null;

      for (const g of games) {
        const start = parseDateMs(g?.startTimeUTC) ?? null;

        const state = String(g?.gameState || "").toUpperCase(); // IN, PRE, FUT, POST, ...
        const isFinished = (state === "POST" || state === "FINAL" || state === "OFF");
        const isLive = (state === "IN");
        const isUpcoming = (state === "PRE" || state === "FUT");

        if (isLive) current = g;

        if (start != null) {
          if (isFinished && start <= now) {
            if (!last || start > (parseDateMs(last.startTimeUTC) ?? -Infinity)) last = g;
          }
          if (isUpcoming && start >= now) {
            if (!next || start < (parseDateMs(next.startTimeUTC) ?? Infinity)) next = g;
          }
          // handle edge case: a live game started in the past
          if (isLive && start <= now) current = g;
        }
      }

      // If no explicit "IN", still allow "PRE" as current candidate if very close and you want it; not needed here.
      return { last, next, current };
    }

    // ============================================================
    // GAMECENTER ENDPOINTS
    // ============================================================
    async function fetchPlayByPlay(gameId) {
      return fetchJson(`https://api-web.nhle.com/v1/gamecenter/${gameId}/play-by-play`);
    }

    async function fetchBoxscore(gameId) {
      return fetchJson(`https://api-web.nhle.com/v1/gamecenter/${gameId}/boxscore`);
    }

    // ============================================================
    // AUDIT (exactly what you requested)
    // ============================================================
    function auditPlays(playByPlayData) {
      const counts = {};
      let missingOwner = 0;

      for (const p of (playByPlayData?.plays || [])) {
        const k = String(p.typeDescKey || "NONE");
        counts[k] = (counts[k] || 0) + 1;
        if (!p.details || p.details.eventOwnerTeamId == null) missingOwner++;
      }

      addLog(`AUDIT typeDescKey counts: ${JSON.stringify(counts)}`, "info");
      addLog(`AUDIT plays missing eventOwnerTeamId: ${missingOwner}`, "info");
    }

    // ============================================================
    // PBP -> plays/goals/penalties/situation (display only)
    // ============================================================
    function formatClock(play) {
      return play?.timeInPeriod || play?.timeRemaining || play?.clock || "";
    }
    function formatPeriod(play) {
      const n = play?.periodDescriptor?.number ?? play?.period ?? "";
      return n ? `P${n}` : "";
    }
    function getSituation(play) {
      return (play?.situationCode || play?.strength || play?.details?.strength || play?.details?.situation || "");
    }
    function describePlay(play) {
      // Prefer explicit descriptions if present
      return (
        play?.details?.eventDescription ||
        play?.details?.description ||
        play?.description ||
        play?.typeDescKey ||
        "play"
      );
    }
    function summarizePlay(play) {
      const k = String(play?.typeDescKey || "").toLowerCase().trim();
      const per = formatPeriod(play);
      const clk = formatClock(play);
      const sit = getSituation(play);
      const head = [per, clk, sit].filter(Boolean).join(" ");
      const desc = describePlay(play);
      return { key: k, head, desc };
    }

    function getLastPlays(playByPlayData, n = 10) {
      const plays = (playByPlayData?.plays || []);
      return plays.slice(-n).map(summarizePlay).reverse(); // newest first
    }

    // ============================================================
    // FIX 1 (your exact replacement): robust key normalize + blocked-shot inversion
    // NOTE: kept even though you will use boxscore totals; this is a fallback/debug tool.
    // ============================================================
    function extractGameStats(playByPlayData, isHome) {
      if (!playByPlayData?.plays) return null;

      let faceoffTeam = 0, faceoffOpp = 0;
      let hitsTeam = 0, hitsOpp = 0;
      let blocksTeam = 0, blocksOpp = 0;

      const homeTeamId = playByPlayData.homeTeam?.id;
      const awayTeamId = playByPlayData.awayTeam?.id;
      const ourTeamId = isHome ? homeTeamId : awayTeamId;
      const oppTeamId = isHome ? awayTeamId : homeTeamId;

      for (const play of playByPlayData.plays) {
        const rawKey = play.typeDescKey;
        const key = String(rawKey || "").toLowerCase().trim();
        const eventTeamId = play.details?.eventOwnerTeamId ?? null;

        const isFaceoff = (key === "faceoff");
        const isHit = (key === "hit");
        const isBlock =
          (key === "blocked-shot" || key === "blocked_shot" || key === "blockedshot");

        if (isFaceoff) {
          if (eventTeamId === ourTeamId) faceoffTeam++;
          else if (eventTeamId === oppTeamId) faceoffOpp++;
          continue;
        }

        if (isHit) {
          if (eventTeamId === ourTeamId) hitsTeam++;
          else if (eventTeamId === oppTeamId) hitsOpp++;
          continue;
        }

        if (isBlock) {
          // IMPORTANT:
          // Many feeds set eventOwnerTeamId = SHOOTING team on a blocked shot.
          // The "block" is credited to the DEFENDING team => invert attribution.
          if (eventTeamId === ourTeamId) blocksOpp++;       // our shot got blocked by opp
          else if (eventTeamId === oppTeamId) blocksTeam++; // opp shot got blocked by us
          continue;
        }
      }

      return { faceoffTeam, faceoffOpp, hitsTeam, hitsOpp, blocksTeam, blocksOpp };
    }

    // ============================================================
    // BOXSCORE -> totals (hits/blocks/faceoffs/shots)
    // Defensive path picking (avoids guessing JSON shape).
    // ============================================================
    function pickFirst(obj, paths) {
      for (const path of paths) {
        const parts = path.split(".");
        let cur = obj;
        let ok = true;
        for (const p of parts) {
          if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
          else { ok = false; break; }
        }
        if (ok && cur != null) return cur;
      }
      return null;
    }

    function getTeamNodeFromBox(box, side) {
      return (
        box?.[`${side}Team`] ||
        box?.teams?.[side] ||
        box?.gameState?.teams?.[side] ||
        null
      );
    }

    function getTeamTotalsFromBox(box, side) {
      const teamNode = getTeamNodeFromBox(box, side);

      const statsRoot =
        pickFirst(teamNode, ["teamStats", "gameStats", "summary.teamGameStats", "summary.teamStats", "teamGameStats"]) ||
        pickFirst(box, [`${side}Team.teamStats`, `summary.${side}Team.teamStats`, `summary.${side}Team.teamGameStats`]) ||
        {};

      const shots =
        pickFirst(statsRoot, ["sog", "shotsOnGoal", "shots"]) ??
        pickFirst(teamNode, ["sog", "shotsOnGoal", "shots"]) ??
        null;

      const hits =
        pickFirst(statsRoot, ["hits"]) ??
        pickFirst(teamNode, ["hits"]) ??
        null;

      const blocks =
        pickFirst(statsRoot, ["blockedShots", "blocks", "blocked"]) ??
        pickFirst(teamNode, ["blockedShots", "blocks", "blocked"]) ??
        null;

      const foWins =
        pickFirst(statsRoot, ["faceoffWins", "faceoffsWon", "foWins"]) ??
        pickFirst(teamNode, ["faceoffWins", "faceoffsWon", "foWins"]) ??
        null;

      const foLoss =
        pickFirst(statsRoot, ["faceoffLosses", "faceoffsLost", "foLosses"]) ??
        pickFirst(teamNode, ["faceoffLosses", "faceoffsLost", "foLosses"]) ??
        null;

      const foPct =
        pickFirst(statsRoot, ["faceoffWinningPctg", "faceoffWinPct", "foPct"]) ??
        pickFirst(teamNode, ["faceoffWinningPctg", "faceoffWinPct", "foPct"]) ??
        null;

      return {
        shots,
        hits,
        blocks,
        faceoffs: { wins: foWins, losses: foLoss, pct: foPct }
      };
    }

    // ============================================================
    // UI helpers
    // ============================================================
    function setText(id, text) {
      const el = document.getElementById(id);
      if (el) el.textContent = text;
    }

    function fmtStartTime(game) {
      const t = game?.startTimeUTC;
      if (!t) return "TBD";
      const d = new Date(t);
      return d.toLocaleString(undefined, { weekday:"short", month:"numeric", day:"numeric", hour:"numeric", minute:"2-digit" });
    }

    function renderPlays(plays) {
      const box = document.getElementById("playsBox");
      if (!box) return;

      if (!plays || plays.length === 0) {
        box.innerHTML = `<div class="muted">No plays available.</div>`;
        return;
      }

      box.innerHTML = plays.map(p => `
        <div class="play">
          <div class="t">${p.head || "‚Äî"}${p.key ? ` ‚Ä¢ ${p.key}` : ""}</div>
          <div class="d">${escapeHtml(p.desc || "")}</div>
        </div>
      `).join("");
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;" }[m]));
    }

    // ============================================================
    // MAIN UPDATE LOOP
    // ============================================================
    let refreshTimer = null;
    let refreshMs = REFRESH_MS_IDLE;

    function setRefreshInterval(ms) {
      if (refreshTimer) clearInterval(refreshTimer);
      refreshMs = ms;
      refreshTimer = setInterval(updatePanel, refreshMs);
    }

    async function updatePanel() {
      const teamAbbr = document.getElementById("teamSelect").value.toUpperCase();

      try {
        setText("hdrTitle", `NHL Panel ‚Äî ${teamAbbr}`);
        setText("hdrSub", "Loading schedule‚Ä¶");

        const scheduleNow = await fetchScheduleNow();
        const { last, next, current } = findRelevantGames(scheduleNow, teamAbbr);

        // Last/Next lines
        if (last) {
          const lastLine = `${buildFullName(last.awayTeam)} @ ${buildFullName(last.homeTeam)} ‚Ä¢ ${fmtStartTime(last)} ‚Ä¢ ${String(last.gameState || "").toUpperCase()}`;
          setText("lastGameLine", lastLine);
        } else {
          setText("lastGameLine", "No recent final game found in /schedule/now window.");
        }

        if (next) {
          const nextLine = `${buildFullName(next.awayTeam)} @ ${buildFullName(next.homeTeam)} ‚Ä¢ ${fmtStartTime(next)} ‚Ä¢ ${String(next.gameState || "").toUpperCase()}`;
          setText("nextGameLine", nextLine);
        } else {
          setText("nextGameLine", "No upcoming game found in /schedule/now window.");
        }

        // Decide which game to show details for: live if exists, else next, else last.
        const chosen = current || next || last;
        if (!chosen?.id) {
          setText("hdrSub", "No game available to display.");
          setText("scoreMeta", "‚Äî");
          setText("scoreLeft", "0");
          setText("scoreRight", "0");
          setText("stShots", "‚Äî");
          setText("stFO", "‚Äî");
          setText("stHits", "‚Äî");
          setText("stBlocks", "‚Äî");
          renderPlays([]);
          setRefreshInterval(REFRESH_MS_IDLE);
          return;
        }

        const state = String(chosen.gameState || "").toUpperCase();
        const isLive = (state === "IN");

        setText("hdrSub", `${buildFullName(chosen.awayTeam)} @ ${buildFullName(chosen.homeTeam)} ‚Ä¢ ${state} ‚Ä¢ GameID ${chosen.id}`);

        // Pull play-by-play + boxscore in parallel (your requested split)
        const [pbp, box] = await Promise.all([
          fetchPlayByPlay(chosen.id),
          fetchBoxscore(chosen.id)
        ]);

        // One-time audit per refresh (you requested)
        auditPlays(pbp);

        // Score: prefer boxscore fields if present; else pbp score fields if present.
        const homeScore = (
          pickFirst(box, ["homeTeam.score", "teams.home.score"]) ??
          pickFirst(pbp, ["homeTeam.score", "homeTeam.goals"]) ??
          0
        );
        const awayScore = (
          pickFirst(box, ["awayTeam.score", "teams.away.score"]) ??
          pickFirst(pbp, ["awayTeam.score", "awayTeam.goals"]) ??
          0
        );

        // Determine whether selected team is home or away in this game
        const homeAbbr = String(chosen?.homeTeam?.abbrev || "").toUpperCase();
        const awayAbbr = String(chosen?.awayTeam?.abbrev || "").toUpperCase();
        const isSelectedHome = (teamAbbr === homeAbbr);

        // Set left/right as "selected team" vs opponent (so the panel stays consistent)
        const leftScore = isSelectedHome ? homeScore : awayScore;
        const rightScore = isSelectedHome ? awayScore : homeScore;

        setText("scoreLeft", String(leftScore));
        setText("scoreRight", String(rightScore));
        setText("scoreMeta", `${teamAbbr} vs ${isSelectedHome ? awayAbbr : homeAbbr} ‚Ä¢ ${isLive ? "LIVE" : state}`);

        // Boxscore totals (team totals)
        const ourSide = isSelectedHome ? "home" : "away";
        const oppSide = isSelectedHome ? "away" : "home";
        const ourTotals = getTeamTotalsFromBox(box, ourSide);
        const oppTotals = getTeamTotalsFromBox(box, oppSide);

        // Shots: show "ours:opp"
        const shotsLine = (ourTotals.shots != null && oppTotals.shots != null)
          ? `${ourTotals.shots}:${oppTotals.shots}`
          : "‚Äî";
        setText("stShots", shotsLine);

        // Faceoffs: prefer wins/losses; else show pct if all you have
        let foLine = "‚Äî";
        const ow = ourTotals.faceoffs?.wins, ol = ourTotals.faceoffs?.losses;
        const pw = oppTotals.faceoffs?.wins, pl = oppTotals.faceoffs?.losses;
        if (ow != null && pw != null) {
          foLine = `${ow}:${pw}`;
        } else if (ourTotals.faceoffs?.pct != null) {
          foLine = `${String(ourTotals.faceoffs.pct)}%`;
        }
        setText("stFO", foLine);

        const hitsLine = (ourTotals.hits != null && oppTotals.hits != null) ? `${ourTotals.hits}:${oppTotals.hits}` : "‚Äî";
        setText("stHits", hitsLine);

        const blocksLine = (ourTotals.blocks != null && oppTotals.blocks != null) ? `${ourTotals.blocks}:${oppTotals.blocks}` : "‚Äî";
        setText("stBlocks", blocksLine);

        // PBP plays
        const plays = getLastPlays(pbp, 10);
        renderPlays(plays);

        // Optional: log fallback PBP counting (debug comparison only)
        const pbpCounts = extractGameStats(pbp, isSelectedHome);
        if (pbpCounts) {
          addLog(
            `PBP fallback counts (debug): FO ${pbpCounts.faceoffTeam}:${pbpCounts.faceoffOpp} | Hits ${pbpCounts.hitsTeam}:${pbpCounts.hitsOpp} | Blocks ${pbpCounts.blocksTeam}:${pbpCounts.blocksOpp}`,
            "info"
          );
        }

        // Refresh cadence
        setRefreshInterval(isLive ? REFRESH_MS_LIVE : REFRESH_MS_IDLE);

        // Your falsifier for ‚Äúkey mismatch‚Äù (printed every refresh):
        // If AUDIT shows non-zero for "hit" and for a blocked-shot key, and totals still show "‚Äî",
        // the cause is not missing keys; it's boxscore parse paths or upstream boxscore not including those stats.
      } catch (err) {
        addLog(`Update failed: ${err.message}`, "error");
        setText("hdrSub", `Error: ${err.message}`);
        setRefreshInterval(REFRESH_MS_IDLE);
      }
    }

    // ============================================================
    // INIT + UI wiring
    // ============================================================
    document.getElementById("refreshNow").addEventListener("click", () => updatePanel());
    document.getElementById("teamSelect").addEventListener("change", () => {
      addLog(`Team changed -> ${document.getElementById("teamSelect").value}`, "warning");
      updatePanel();
    });

    addLog("System started (direct NHL endpoints, no Home Assistant)", "success");
    updatePanel();
    setRefreshInterval(REFRESH_MS_IDLE);
  </script>
</body>
</html>
