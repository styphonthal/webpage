<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Buffalo Sabres — Scores & Goals</title>
<style>
  :root{
    --sabres-navy: #002654;
    --sabres-gold: #FCB514;
    --sabres-white: #f7f9fc;
    --bg-deep: #001631;
  }
  *{box-sizing:border-box; margin:0; padding:0}
  html,body{height:100%; min-height:100vh}
  body{
    color:var(--sabres-white);
    background:
      radial-gradient(1200px 700px at 80% 10%, rgba(252,181,20,.12), transparent 60%),
      radial-gradient(900px 500px at 20% 80%, rgba(0,38,84,.35), transparent 70%),
      var(--bg-deep);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
    padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  .wrap{
    max-width:1200px;
    width:100%;
    margin:0 auto;
    padding:28px clamp(16px, 3vw, 36px);
  }

  /* Team Header */
  .team-header{
    position:relative;
    text-align:center;
    margin-bottom:24px;
    padding:24px 20px;
    background: linear-gradient(180deg, rgba(0,38,84,.65), rgba(0,28,62,.65));
    border: 2px solid rgba(252,181,20,.25);
    border-radius:18px;
    box-shadow: 0 8px 24px rgba(0,0,0,.3);
    overflow:hidden;
  }

  /* Slug images (large, centered on sides) */
  .slug{
    position:absolute;
    top:50%;
    transform:translateY(-50%);
    height:200px;
    width:auto;
    opacity:.92;
    pointer-events:none;

    /* "Pop" (1+2): drop shadow + subtle glow/emboss */
    filter:
      drop-shadow(0 12px 20px rgba(0,0,0,.45))
      drop-shadow(0 0 10px rgba(252,181,20,.18))
      drop-shadow(0 0 2px rgba(255,255,255,.12));
  }
  .slug-left{ left:18px; }
  .slug-right{ right:18px; transform:translateY(-50%) scaleX(-1); }

  .team-header-inner{
    position:relative;
    z-index:1;
    max-width:820px;
    margin:0 auto;
    padding:0 240px; /* prevent overlap with big slugs */
  }

  /* Header image (sabres2.png) */
  .header-logo{
    display:block;
    margin:0 auto 12px;
    max-width:min(520px, 86vw);
    height:auto;
    image-rendering:auto;
    filter: drop-shadow(0 8px 16px rgba(0,0,0,.35));
  }

  .team-stats{
    display:flex;
    justify-content:center;
    gap:32px;
    flex-wrap:wrap;
    margin-top:6px;
  }

  .stat-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:4px;
  }

  .stat-label{
    font-size:.9rem;
    color:#a8c5f5;
    font-weight:600;
    text-transform:uppercase;
    letter-spacing:.5px;
  }

  .stat-value{
    font-size:1.25rem;
    color:var(--sabres-gold);
    font-weight:800;
  }

  .top-scorer{
    margin-top:12px;
    padding-top:12px;
    border-top:1px solid rgba(252,181,20,.2);
    color:#cfe1ff;
    font-size:1.05rem;
  }

  .top-scorer strong{
    color:var(--sabres-gold);
    font-weight:800;
  }

  /* Score header */
  .scorebar{
    display:flex;
    flex-direction:column;
    gap:14px;
    background: linear-gradient(180deg, rgba(0,38,84,.85), rgba(0,28,62,.85));
    border: 2px solid rgba(252,181,20,.35);
    border-radius:18px;
    padding:18px 20px;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
  }

  .score-top{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center;
    gap:16px;
    min-width:0;
  }

  .team{
    display:flex;
    flex-direction:column;
    gap:8px;
    min-width:0;
  }

  .team.away{ align-items:flex-end; text-align:right; }
  .team.home{ align-items:flex-start; text-align:left; }

  .team-name-row{
    display:flex;
    align-items:center;
    gap:12px;
    min-width:0;
  }
  .team.away .team-name-row{ justify-content:flex-end; }
  .team.home .team-name-row{ justify-content:flex-start; }

  .badge{
    width:64px;
    height:64px;
    border-radius:12px;
    background-size:contain;
    background-position:center;
    background-repeat:no-repeat;
    border:2px solid rgba(252,181,20,.3);
    flex-shrink:0;
  }

  .name{
    font-weight:900;
    letter-spacing:.3px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    font-size:1.18rem;
  }

  .team-metrics{
    display:grid;
    gap:4px;
    color:#cfe1ff;
    font-size:.95rem;
    opacity:.95;
  }
  .metric b{ color:#ffe9b3; font-weight:900; }
  .metric span{ color:#cfe1ff; }

  .center-stack{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    min-width:210px;
  }

  .score{
    font-weight:900;
    font-size:2.6rem;
    color:var(--sabres-gold);
    white-space:nowrap;
    line-height:1.05;
  }

  .mid-meta{
    text-align:center;
    color:#cfe1ff;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .state{
    font-weight:900;
    font-size:1.05rem;
  }
  .pill{
    display:inline-block;
    font-size:.9rem;
    padding:5px 12px;
    border-radius:999px;
    background: rgba(252,181,20,.18);
    border:1px solid rgba(252,181,20,.35);
    color:#ffe9b3;
    font-weight:900;
  }
  .muted{
    font-size:.85rem;
    opacity:.75;
  }

  /* Panels */
  .panel{
    margin-top:20px;
    background: linear-gradient(180deg, rgba(0,38,84,.72), rgba(0,28,62,.72));
    border: 1px solid rgba(252,181,20,.28);
    border-radius:16px;
    padding:18px 20px;
  }

  .panel h3{
    margin:0 0 14px 0;
    font-size:1.15rem;
    color:#ffe9b3;
    border-bottom:1px solid rgba(252,181,20,.2);
    padding-bottom:8px;
  }

  .game-summary{
    display:flex;
    flex-direction:column;
    gap:8px;
    font-size:1rem;
  }

  .game-summary strong{
    color:var(--sabres-gold);
    font-weight:900;
  }

  /* Goals list */
  .goals{
    display:grid;
    gap:12px;
    margin-top:14px;
  }

  .goal{
    display:grid;
    grid-template-columns: 110px 1fr;
    gap:14px;
    align-items:start;
    padding:12px 14px;
    border-radius:12px;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(252,181,20,.15);
    transition:all .2s;
  }

  .goal:hover{
    background: rgba(252,181,20,.08);
    border-color:rgba(252,181,20,.3);
  }

  .time{
    font-weight:900;
    color:#ffe3a3;
    font-size:.95rem;
  }

  .goal-details{
    display:flex;
    flex-direction:column;
    gap:4px;
  }

  .who{
    font-weight:900;
    color:var(--sabres-white);
  }

  .team-name{
    color:var(--sabres-gold);
    font-weight:900;
  }

  .assist{
    color:#c6d6f6;
    font-size:.92rem;
    margin-top:2px;
  }

  .assist-player{
    display:inline-block;
    margin-right:8px;
  }

  .sep{
    opacity:.4;
    padding:0 6px;
  }

  .strength{
    color:#a8c5f5;
    font-size:.85rem;
    font-weight:900;
  }

  .loading, .error, .info{
    text-align:center;
    padding:20px;
    color:#c6d6f6;
  }

  .error{
    color:#ff9999;
  }

  .info{
    color:#a8c5f5;
    font-size:.95rem;
    line-height:1.6;
  }

  /* Mobile safeguards */
  @media (max-width: 980px){
    .team-header-inner{ padding:0 200px; }
    .slug{ height:170px; }
  }
  @media (max-width:768px){
    .team-header-inner{ padding:0 96px; }
    .slug{ height:120px; opacity:.65; }
    .slug-left{ left:10px; }
    .slug-right{ right:10px; }

    .score-top{
      grid-template-columns: 1fr;
      gap:14px;
    }

    .team.away, .team.home{
      align-items:center;
      text-align:center;
    }
    .team.away .team-name-row,
    .team.home .team-name-row{
      justify-content:center;
    }

    .center-stack{
      min-width:auto;
    }

    .score{ font-size:2.2rem; }

    .goal{
      grid-template-columns: 96px 1fr;
      gap:10px;
    }
  }

  @media (max-width:480px){
    .team-header-inner{ padding:0 18px; }
    .slug{ display:none; }

    .badge{ width:56px; height:56px; }
    .name{ font-size:1.05rem; }
    .score{ font-size:2rem; }

    .header-logo{ max-width:92vw; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Team Header -->
    <div class="team-header">
      <img class="slug slug-left" src="slug.png" alt="" aria-hidden="true">
      <img class="slug slug-right" src="slug.png" alt="" aria-hidden="true">

      <div class="team-header-inner">
        <img class="header-logo" src="sabres2.png?v=123" alt="Buffalo Sabres">

        <div class="team-stats">
          <div class="stat-item">
            <span class="stat-label">Record</span>
            <span class="stat-value" id="record">—</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Points</span>
            <span class="stat-value" id="points">—</span>
          </div>
        </div>

        <!-- NEW: last 5 + streak (below record/points, above standings) -->
        <div class="top-scorer" id="formStreakLine" style="margin-top:10px;">
          Loading form…
        </div>

        <!-- standings position line -->
        <div class="top-scorer" id="standingLine" style="margin-top:10px; border-top:1px solid rgba(252,181,20,.2);">
          Loading standings…
        </div>

        <!-- leaders -->
        <div class="top-scorer" id="topGoals">
          Loading leading goals...
        </div>
        <div class="top-scorer" id="topPoints" style="margin-top:8px; border-top:none; padding-top:0;">
          Loading leading points...
        </div>
      </div>
    </div>

    <!-- Primary score bar -->
    <div class="scorebar" id="scorebar">
      <div class="score-top">
        <!-- Away -->
        <div class="team away" id="awayTeam">
          <div class="team-name-row">
            <div class="name">Away</div>
            <div class="badge" id="awayBadge"></div>
          </div>

          <!-- Metrics -->
          <div class="team-metrics" id="awayMetrics">
            <div class="metric"><b>SOG</b>: <span id="awaySog">—</span></div>
            <div class="metric"><b>Hits</b>: <span id="awayHits">—</span></div>
            <div class="metric"><b>Blk</b>: <span id="awayBlocks">—</span></div>
            <div class="metric"><b>G</b>: <span id="awayGoalie">—</span></div>
          </div>
        </div>

        <!-- Center -->
        <div class="center-stack">
          <div class="score" id="score">— — —</div>
          <div class="mid-meta">
            <div class="state" id="state">Loading…</div>
            <div><span class="pill" id="when"></span></div>
            <div class="muted" id="updated"></div>
          </div>
        </div>

        <!-- Home -->
        <div class="team home" id="homeTeam">
          <div class="team-name-row">
            <div class="badge" id="homeBadge"></div>
            <div class="name">Home</div>
          </div>

          <!-- Metrics -->
          <div class="team-metrics" id="homeMetrics">
            <div class="metric"><b>SOG</b>: <span id="homeSog">—</span></div>
            <div class="metric"><b>Hits</b>: <span id="homeHits">—</span></div>
            <div class="metric"><b>Blk</b>: <span id="homeBlocks">—</span></div>
            <div class="metric"><b>G</b>: <span id="homeGoalie">—</span></div>
          </div>
        </div>
      </div>

      <!-- Live Goals attached to active game box -->
      <div class="panel" id="liveGoalsPanel" style="margin-top:0;">
        <h3>Goals</h3>
        <div class="goals" id="goals"><div class="loading">Loading goals…</div></div>
      </div>
    </div>

    <!-- Most Recent Game (game BEFORE the live/primary game if primary is live) -->
    <div class="panel" id="lastGamePanel">
      <h3>Most Recent Game</h3>
      <div id="lastGameBox" class="loading">Loading…</div>
      <div class="goals" id="lastGameGoals"></div>
    </div>

    <!-- Next Game -->
    <div class="panel" id="nextGamePanel">
      <h3>Next Game</h3>
      <div id="nextGameBox" class="loading">Loading…</div>
    </div>
  </div>

<script>
(async function(){
  const SABRES_ABBR = 'BUF';
  const CORS_PROXY = 'https://corsproxy.io/?';

  // Helper functions
  const setTxt = (id, t) => {
    const el = document.getElementById(id);
    if (el) el.textContent = t;
  };

  const setHTML = (id, html) => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  };

  function formatDate(dateStr) {
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        timeZone: 'America/New_York',
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    } catch {
      return dateStr;
    }
  }

  function getTeamLogo(abbr) {
    return `https://assets.nhle.com/logos/nhl/svg/${abbr}_light.svg`;
  }

  function teamLabel(t) {
    return t?.placeName?.default
        || t?.commonName?.default
        || t?.name?.default
        || t?.abbrev
        || '';
  }

  function setUpdatedNow() {
    const el = document.getElementById('updated');
    if (!el) return;
    el.textContent = `Updated ${new Date().toLocaleTimeString('en-US', {
      timeZone: 'America/New_York',
      hour: 'numeric',
      minute: '2-digit',
      second: '2-digit'
    })}`;
  }

  async function fetchJSON(url) {
    const proxiedUrl = CORS_PROXY + encodeURIComponent(url);
    const response = await fetch(proxiedUrl, { cache: 'no-store' });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  }

  // Get team standings and stats (record + points)
  async function getTeamStats() {
    try {
      const url = `https://api-web.nhle.com/v1/standings/now`;
      const data = await fetchJSON(url);

      let sabres = null;
      for (const standing of data.standings || []) {
        if (standing.teamAbbrev?.default === SABRES_ABBR) {
          sabres = standing;
          break;
        }
      }
      if (!sabres) return { wins: 0, losses: 0, otLosses: 0, points: 0 };

      return {
        wins: sabres.wins || 0,
        losses: sabres.losses || 0,
        otLosses: sabres.otLosses || 0,
        points: sabres.points || 0
      };
    } catch {
      return null;
    }
  }

  // conference/division/league ranks
  async function getSabresStandingsPosition() {
    try {
      const url = `https://api-web.nhle.com/v1/standings/now`;
      const data = await fetchJSON(url);

      let sabres = null;
      for (const standing of data.standings || []) {
        if (standing.teamAbbrev?.default === SABRES_ABBR) {
          sabres = standing;
          break;
        }
      }
      if (!sabres) return null;

      const conference = sabres.conferenceName || sabres.conferenceAbbrev || sabres.conference || (sabres.conferenceName?.default ?? null);
      const conferenceRank = sabres.conferenceSequence ?? sabres.conferenceRank ?? sabres.conferencePlace ?? sabres.conferenceStanding ?? null;

      const division = sabres.divisionName || sabres.divisionAbbrev || sabres.division || (sabres.divisionName?.default ?? null);
      const divisionRank = sabres.divisionSequence ?? sabres.divisionRank ?? sabres.divisionPlace ?? sabres.divisionStanding ?? null;

      const leagueRank = sabres.leagueSequence ?? sabres.leagueRank ?? sabres.leaguePlace ?? sabres.leagueStanding ?? null;

      const confLabel =
        (typeof conference === 'string' && conference.trim()) ? conference :
        (sabres.conferenceAbbrev?.default || sabres.conferenceName?.default || sabres.conference || 'Conference');

      return {
        conference: confLabel,
        conferenceRank: conferenceRank ?? '—',
        division: (typeof division === 'string' && division.trim()) ? division : (sabres.divisionAbbrev?.default || sabres.divisionName?.default || sabres.division || 'Division'),
        divisionRank: divisionRank ?? '—',
        leagueRank: leagueRank ?? '—'
      };
    } catch {
      return null;
    }
  }

  // Get roster and find leaders (goals + points)
  async function getLeaders() {
    try {
      const url = `https://api-web.nhle.com/v1/club-stats/${SABRES_ABBR}/now`;
      const data = await fetchJSON(url);

      const skaters = data.skaters || [];
      if (!skaters.length) return null;

      const bestGoals = skaters.reduce((best, p) => (p.goals||0) > (best.goals||0) ? p : best, skaters[0]);
      const bestPoints = skaters.reduce((best, p) => (p.points||0) > (best.points||0) ? p : best, skaters[0]);

      const name = (p) => `${p.firstName?.default || ''} ${p.lastName?.default || ''}`.trim();

      return {
        goals: { name: name(bestGoals), val: bestGoals.goals || 0 },
        points: { name: name(bestPoints), val: bestPoints.points || 0 }
      };
    } catch {
      return null;
    }
  }

  async function getSchedule() {
    const now = new Date();
    const formatAPIDate = (d) => d.toISOString().split('T')[0];

    const url = `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${formatAPIDate(now)}`;
    const data = await fetchJSON(url);

    const prevWeek = new Date(now);
    prevWeek.setDate(prevWeek.getDate() - 7);
    const prevUrl = `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${formatAPIDate(prevWeek)}`;
    const prevData = await fetchJSON(prevUrl);

    const allGames = [...(prevData.games || []), ...(data.games || [])];

    const liveGame = allGames.find(g =>
      g.gameState === 'LIVE' ||
      g.gameState === 'CRIT' ||
      g.gameState === 'CRITICAL'
    );

    const finalsSorted = allGames
      .filter(g => (g.gameState === 'OFF' || g.gameState === 'FINAL'))
      .sort((a,b) => new Date(b.startTimeUTC) - new Date(a.startTimeUTC));

    const lastGame = finalsSorted[0];

    const prevFinalBefore = (() => {
      if (liveGame) {
        const liveStart = new Date(liveGame.startTimeUTC).getTime();
        return finalsSorted.find(g => new Date(g.startTimeUTC).getTime() < liveStart) || null;
      }
      return finalsSorted.length > 1 ? finalsSorted[1] : null;
    })();

    const nextGame = allGames
      .filter(g => g.gameState === 'FUT' || g.gameState === 'PRE')
      .sort((a, b) => new Date(a.startTimeUTC) - new Date(b.startTimeUTC))[0];

    return { liveGame, lastGame, prevFinalBefore, nextGame, games: allGames, finalsSorted };
  }

  // Get game details with cache buster
  async function getGameDetails(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/play-by-play?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  // Boxscore for SOG/Hits/Blocks/Goalie sv%
  async function getGameBoxscore(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/boxscore?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  // Save% formatting: .XXX (standard)
  function formatSavePctDotFromSavesShots(saves, shots) {
    const s = Number(saves);
    const sh = Number(shots);
    if (!Number.isFinite(s) || !Number.isFinite(sh) || sh <= 0) return '—';
    const pct = s / sh; // 0.xxx
    const thou = Math.round(pct * 1000);
    return `.${String(thou).padStart(3,'0')}`;
  }

  // Parse strings like "16/20" (saves/shots) anywhere on goalie object
  function parseSavesShotsFromGoalie(goalieObj) {
    if (!goalieObj) return null;

    // direct numeric-ish fields (varies)
    const saves =
      goalieObj.saves ?? goalieObj.saveCount ?? goalieObj.totalSaves ?? null;
    const shots =
      goalieObj.shotsAgainst ?? goalieObj.shots ?? goalieObj.totalShotsAgainst ?? goalieObj.sa ?? null;

    if (saves != null && shots != null) {
      const s = Number(String(saves).replace(/[^\d.]/g,''));
      const sh = Number(String(shots).replace(/[^\d.]/g,''));
      if (Number.isFinite(s) && Number.isFinite(sh)) return { saves:s, shots:sh };
    }

    // sum all "*ShotsAgainst" strings like "16/20"
    let totalSaves = 0;
    let totalShots = 0;
    let foundAny = false;

    for (const [k,v] of Object.entries(goalieObj)) {
      if (!v) continue;
      if (!/ShotsAgainst$/i.test(k)) continue;
      const m = String(v).match(/(\d+)\s*\/\s*(\d+)/);
      if (!m) continue;
      const s = Number(m[1]);
      const sh = Number(m[2]);
      if (Number.isFinite(s) && Number.isFinite(sh)) {
        totalSaves += s;
        totalShots += sh;
        foundAny = true;
      }
    }

    return foundAny ? { saves: totalSaves, shots: totalShots } : null;
  }

  function goalieName(goalieObj) {
    if (!goalieObj) return 'Goalie';
    const ln = goalieObj.lastName?.default || goalieObj.lastName || goalieObj.name?.default || goalieObj.name || '';
    if (typeof ln === 'string' && ln.trim()) return ln.trim();

    // sometimes: name.default = "Lastname"
    const nm = goalieObj.name?.default || goalieObj.name;
    return (typeof nm === 'string' && nm.trim()) ? nm.trim() : 'Goalie';
  }

  function goalieLabel(goalieObj) {
    if (!goalieObj) return '—';
    const nm = goalieName(goalieObj);

    // prefer computed from saves/shots; fallback to any raw savePct fields if present
    const ss = parseSavesShotsFromGoalie(goalieObj);
    if (ss && ss.shots > 0) {
      return `${nm} (${formatSavePctDotFromSavesShots(ss.saves, ss.shots)})`;
    }

    const svRaw =
      goalieObj.savePctg ?? goalieObj.savePercentage ?? goalieObj.savePct ?? goalieObj.svPct ?? goalieObj.savePctgDecimal ??
      goalieObj.savePctgValue ?? goalieObj.savePctValue ?? null;

    if (svRaw != null) {
      const s = (typeof svRaw === 'string') ? svRaw.trim().replace('%','') : svRaw;
      let num = (typeof s === 'number') ? s : Number(s);
      if (Number.isFinite(num)) {
        if (num > 1.5) num = num / 100;
        return `${nm} (.${String(Math.round(num * 1000)).padStart(3,'0')})`;
      }
    }

    return `${nm} (—)`;
  }

  // Extract team totals:
  // - First try top-level team totals
  // - Then try playerByGameStats.team object
  // - Then compute by summing player stats (hits/blockedShots) on skaters list
  function getPGSTeam(side, box) {
    const pgs = box?.playerByGameStats;
    if (!pgs) return null;
    return side === 'away' ? pgs.awayTeam : pgs.homeTeam;
  }

  function getTopTeam(side, box) {
    return side === 'away' ? (box?.awayTeam || box?.away) : (box?.homeTeam || box?.home);
  }

  function pickFirstNonNull(...vals) {
    for (const v of vals) {
      if (v !== undefined && v !== null && v !== '') return v;
    }
    return null;
  }

  function sumSkaterStat(pgsTeam, keys) {
    const skaters = pgsTeam?.skaters;
    if (!Array.isArray(skaters) || !skaters.length) return null;

    let sum = 0;
    let found = false;

    for (const s of skaters) {
      for (const k of keys) {
        const v = s?.[k];
        if (v === undefined || v === null) continue;
        const n = Number(String(v).replace(/[^\d.-]/g,''));
        if (!Number.isFinite(n)) continue;
        sum += n;
        found = true;
        break;
      }
    }
    return found ? sum : null;
  }

  function extractTeamTotal(side, box, stat) {
    const top = getTopTeam(side, box);
    const pgsTeam = getPGSTeam(side, box);

    // common direct keys
    if (stat === 'sog') {
      return pickFirstNonNull(
        top?.shotsOnGoal, top?.sog, top?.shots,
        top?.teamStats?.shotsOnGoal, top?.teamStats?.sog,
        pgsTeam?.shotsOnGoal, pgsTeam?.sog, pgsTeam?.shots,
        pgsTeam?.teamStats?.shotsOnGoal, pgsTeam?.teamStats?.sog
      );
    }

    if (stat === 'hits') {
      const direct = pickFirstNonNull(
        top?.hits, top?.teamStats?.hits,
        pgsTeam?.hits, pgsTeam?.teamStats?.hits
      );
      if (direct != null) return direct;

      // compute from skaters
      return sumSkaterStat(pgsTeam, ['hits', 'hitCount']);
    }

    if (stat === 'blockedShots') {
      const direct = pickFirstNonNull(
        top?.blockedShots, top?.blocks, top?.blocked,
        top?.teamStats?.blockedShots, top?.teamStats?.blocks, top?.teamStats?.blocked,
        pgsTeam?.blockedShots, pgsTeam?.blocks, pgsTeam?.blocked,
        pgsTeam?.teamStats?.blockedShots, pgsTeam?.teamStats?.blocks, pgsTeam?.teamStats?.blocked
      );
      if (direct != null) return direct;

      // compute from skaters
      return sumSkaterStat(pgsTeam, ['blockedShots', 'blocks', 'blocked']);
    }

    return null;
  }

  // Pick goalie: choose the goalie who actually faced shots (max shots), not index 0
  function findLikelyGoalie(side, box) {
    const pgsTeam = getPGSTeam(side, box);
    const top = getTopTeam(side, box);

    const candidates = [];

    const pgsGoalies = pgsTeam?.goalies;
    if (Array.isArray(pgsGoalies)) candidates.push(...pgsGoalies);

    const topGoalies = top?.goalies || top?.goalieStats;
    if (Array.isArray(topGoalies)) candidates.push(...topGoalies);

    if (!candidates.length) return null;

    // choose by max total shots against (derived from saves/shots strings or shotsAgainst)
    let best = null;
    let bestShots = -1;

    for (const g of candidates) {
      const ss = parseSavesShotsFromGoalie(g);
      const shots = ss?.shots ?? (() => {
        const raw = g.shotsAgainst ?? g.shots ?? g.sa ?? null;
        const n = Number(String(raw).replace(/[^\d.]/g,''));
        return Number.isFinite(n) ? n : 0;
      })();

      if (shots > bestShots) {
        bestShots = shots;
        best = g;
      }
    }

    // if everyone is 0 shots, fallback to first (still deterministic)
    return best || candidates[0];
  }

  function applyTeamMetrics(side, box) {
    const sog = extractTeamTotal(side, box, 'sog');
    const hits = extractTeamTotal(side, box, 'hits');
    const blocks = extractTeamTotal(side, box, 'blockedShots');

    const goalie = findLikelyGoalie(side, box);

    setTxt(side + 'Sog', sog != null ? String(sog) : '—');
    setTxt(side + 'Hits', hits != null ? String(hits) : '—');
    setTxt(side + 'Blocks', blocks != null ? String(blocks) : '—');
    setTxt(side + 'Goalie', goalieLabel(goalie));
  }

  // Render the main scorebar
  function renderScorebar(game, details, boxscore) {
    if (!game) {
      setTxt('state', 'No game data');
      setTxt('when', '—');
      return;
    }

    const away = details?.awayTeam || game.awayTeam;
    const home = details?.homeTeam || game.homeTeam;

    document.querySelector('#awayTeam .name').textContent = teamLabel(away);
    document.querySelector('#homeTeam .name').textContent = teamLabel(home);

    const awayAbbrev = away.abbrev || game.awayTeam?.abbrev;
    const homeAbbrev = home.abbrev || game.homeTeam?.abbrev;

    document.getElementById('awayBadge').style.backgroundImage = `url('${getTeamLogo(awayAbbrev)}')`;
    document.getElementById('homeBadge').style.backgroundImage = `url('${getTeamLogo(homeAbbrev)}')`;

    const awayScore = details?.awayTeam?.score ?? game.awayTeam?.score ?? 0;
    const homeScore = details?.homeTeam?.score ?? game.homeTeam?.score ?? 0;
    setTxt('score', `${awayScore} — ${homeScore}`);

    const gameState = details?.gameState || game.gameState;
    const isLive = ['LIVE', 'CRIT', 'CRITICAL'].includes(gameState);

    let status = 'Final';
    if (isLive) {
      status = 'LIVE';
      if (details?.periodDescriptor) {
        const period = details.periodDescriptor.number;
        const periodType = details.periodDescriptor.periodType;
        if (periodType === 'OT') status = 'OVERTIME';
        else if (periodType === 'SO') status = 'SHOOTOUT';
        else status = `${period}${period === 1 ? 'st' : period === 2 ? 'nd' : period === 3 ? 'rd' : 'th'} Period`;
      }
      if (details?.clock?.inIntermission) status = 'Intermission';
    } else if (['FUT', 'PRE'].includes(gameState)) status = 'Scheduled';
    else if (['FINAL', 'OFF'].includes(gameState)) status = 'Final';

    setTxt('state', status);

    // time/when (prefer intermission remaining if present)
    let when = '';
    if (isLive) {
      if (details?.clock?.inIntermission) {
        const ir =
          details.clock.intermissionTimeRemaining ||
          details.clock.intermissionRemaining ||
          details.clock.intermissionTimeRemainingSeconds ||
          details.clock.intermissionTimeLeft;

        if (typeof ir === 'string' && ir.trim()) when = `INT ${ir}`;
        else if (typeof ir === 'number' && Number.isFinite(ir)) {
          const mm = Math.floor(ir / 60);
          const ss = String(ir % 60).padStart(2, '0');
          when = `INT ${mm}:${ss}`;
        } else {
          when = 'Intermission';
        }
      } else {
        when = details?.clock?.timeRemaining || '';
      }
    } else {
      when = formatDate(game.startTimeUTC);
    }
    setTxt('when', when || '—');

    // team metrics
    if (boxscore) {
      applyTeamMetrics('away', boxscore);
      applyTeamMetrics('home', boxscore);
    } else {
      ['awaySog','homeSog','awayHits','homeHits','awayBlocks','homeBlocks','awayGoalie','homeGoalie'].forEach(id => setTxt(id, '—'));
    }
  }

  function buildPlayerMap(details) {
    const playerMap = new Map();
    const roster = details?.rosterSpots || [];
    for (const p of roster) {
      if (!p?.playerId) continue;
      const nm = `${p.firstName?.default || ''} ${p.lastName?.default || ''}`.trim();
      playerMap.set(p.playerId, nm);
    }
    return playerMap;
  }

  function timeToSec(t) {
    if (!t) return 0;
    const parts = String(t).split(':');
    const mm = parseInt(parts[0] || '0', 10);
    const ss = parseInt(parts[1] || '0', 10);
    return (mm * 60) + ss;
  }

  // Render goals into a specific container, newest-first by default
  function renderGoals(details, containerId, newestFirst = true) {
    const goalsEl = document.getElementById(containerId);
    if (!goalsEl) return;

    if (!details) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const plays = details.plays || details.gameEvents || [];
    if (!plays || !plays.length) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const playerMap = buildPlayerMap(details);

    let goals = plays
      .filter(p => p.typeDescKey === 'goal' || p.typeCode === 'GOAL')
      .filter(p => p.periodDescriptor?.periodType !== 'SO'); // exclude shootout

    if (!goals.length) {
      goalsEl.innerHTML = '<div class="loading">No goals scored yet</div>';
      return;
    }

    goals.sort((a,b) => {
      const pd = (a.periodDescriptor?.number || 0) - (b.periodDescriptor?.number || 0);
      if (pd !== 0) return pd;
      return timeToSec(a.timeInPeriod) - timeToSec(b.timeInPeriod);
    });
    if (newestFirst) goals.reverse();

    let html = '';
    for (const goal of goals) {
      const period = goal.periodDescriptor?.number || '';
      const time = goal.timeInPeriod || '';
      const teamId = goal.details?.eventOwnerTeamId;

      const teamInfo = (details.homeTeam?.id === teamId) ? details.homeTeam : details.awayTeam;
      const tName = teamLabel(teamInfo);

      let scorerName = 'Unknown';
      let goalNumber = '';

      if (goal.details) {
        const scorerId = goal.details.scoringPlayerId || goal.details.playerId;
        if (scorerId && playerMap.has(scorerId)) scorerName = playerMap.get(scorerId);
        else if (goal.details.scoringPlayer) scorerName = goal.details.scoringPlayer;
        if (goal.details.scoringPlayerTotal) goalNumber = ` (${goal.details.scoringPlayerTotal})`;
      }

      const assists = [];
      if (goal.details) {
        const a1 = goal.details.assist1PlayerId;
        if (a1 && playerMap.has(a1)) {
          assists.push(`${playerMap.get(a1)}${goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : ''}`);
        } else if (goal.details.assist1Player) {
          assists.push(`${goal.details.assist1Player}${goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : ''}`);
        }

        const a2 = goal.details.assist2PlayerId;
        if (a2 && playerMap.has(a2)) {
          assists.push(`${playerMap.get(a2)}${goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : ''}`);
        } else if (goal.details.assist2Player) {
          assists.push(`${goal.details.assist2Player}${goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : ''}`);
        }
      }

      const strength = goal.details?.strength || 'ev';
      const situation = goal.details?.situationCode || '';

      html += `
        <div class="goal">
          <div class="time">P${period}<br>${time}</div>
          <div class="goal-details">
            <div>
              <span class="team-name">${tName}</span>
              <span class="sep">—</span>
              <span class="who">${scorerName}${goalNumber}</span>
            </div>
            <div class="strength">${String(strength).toUpperCase()}${situation ? ` (${situation})` : ''}</div>
            ${assists.length ? `<div class="assist">Assists: ${assists.map(a => `<span class="assist-player">${a}</span>`).join('')}</div>` : ''}
          </div>
        </div>
      `;
    }

    goalsEl.innerHTML = html;
  }

  function renderGameSummary(game, targetId) {
    const el = document.getElementById(targetId);
    if (!el) return;

    if (!game) {
      el.innerHTML = '<div class="loading">No game data</div>';
      return;
    }

    const away = game.awayTeam;
    const home = game.homeTeam;
    const when = formatDate(game.startTimeUTC);

    el.innerHTML = `
      <div class="game-summary">
        <div><strong>${teamLabel(away)}</strong> at <strong>${teamLabel(home)}</strong></div>
        <div>${(game.gameState === 'OFF' || game.gameState === 'FINAL') ? `Final: ${away.score || 0} — ${home.score || 0}` : ''}</div>
        <div>${when}</div>
      </div>
    `;
  }

  function setGoalsVisibility(show) {
    const liveGoalsPanel = document.getElementById('liveGoalsPanel');
    if (!liveGoalsPanel) return;
    liveGoalsPanel.style.display = show ? '' : 'none';
  }

  function isSabresHome(game) {
    return (game?.homeTeam?.abbrev === SABRES_ABBR);
  }

  function sabresResultLetter(game) {
    if (!game) return null;
    const away = game.awayTeam;
    const home = game.homeTeam;
    const sabresAreHome = isSabresHome(game);

    const sabresScore = sabresAreHome ? (home?.score ?? 0) : (away?.score ?? 0);
    const oppScore = sabresAreHome ? (away?.score ?? 0) : (home?.score ?? 0);

    if (sabresScore > oppScore) return 'W';
    if (sabresScore < oppScore) return 'L';
    return 'T';
  }

  function computeLast5AndStreak(finalsSorted) {
    // finalsSorted is newest->oldest
    const finals = Array.isArray(finalsSorted) ? finalsSorted : [];
    const last5Games = finals.slice(0, 5);
    const last5 = last5Games.map(sabresResultLetter).filter(Boolean);

    // streak from newest backward
    let streakType = null; // 'W' or 'L' or 'T'
    let streakCount = 0;
    for (const g of finals) {
      const r = sabresResultLetter(g);
      if (!r) continue;
      if (streakType === null) {
        streakType = r;
        streakCount = 1;
      } else if (r === streakType) {
        streakCount++;
      } else {
        break;
      }
    }

    return {
      last5: last5.length ? last5.join('-') : null,
      streakType,
      streakCount
    };
  }

  // Main execution
  try {
    const schedule = await getSchedule();

    // team header: record/points
    const teamStats = await getTeamStats().catch(()=>null);
    if (teamStats) {
      setTxt('record', `${teamStats.wins}-${teamStats.losses}-${teamStats.otLosses}`);
      setTxt('points', String(teamStats.points));
    } else {
      setTxt('record', '—');
      setTxt('points', '—');
    }

    // last 5 + streak (below record/points, above standings)
    const form = computeLast5AndStreak(schedule.finalsSorted);
    if (form.last5) {
      const streakWord = form.streakType === 'W' ? 'win' : form.streakType === 'L' ? 'loss' : 'tie';
      const streakText = (form.streakType && form.streakCount)
        ? `Streak: <strong>${form.streakCount}</strong> ${streakWord}${form.streakCount === 1 ? '' : 's'}`
        : `Streak: —`;

      setHTML('formStreakLine', `Last 5: <strong>${form.last5}</strong> &nbsp; <span style="opacity:.8">|</span> &nbsp; ${streakText}`);
    } else {
      setHTML('formStreakLine', 'Form unavailable');
    }

    // standings line
    const pos = await getSabresStandingsPosition().catch(()=>null);
    if (pos) {
      setHTML(
        'standingLine',
        `Conference: <strong>${pos.conferenceRank}</strong> &nbsp; <span style="opacity:.8">|</span> &nbsp; Division: <strong>${pos.divisionRank}</strong> &nbsp; <span style="opacity:.8">|</span> &nbsp; League: <strong>${pos.leagueRank}</strong>`
      );
    } else {
      setHTML('standingLine', 'Standings position unavailable');
    }

    // leaders
    const leaders = await getLeaders().catch(()=>null);
    if (leaders) {
      setHTML('topGoals', `Leading goals: <strong>${leaders.goals.name}</strong>, ${leaders.goals.val}`);
      setHTML('topPoints', `Leading points: <strong>${leaders.points.name}</strong>, ${leaders.points.val}`);
    } else {
      setHTML('topGoals', 'Leading goals unavailable');
      setHTML('topPoints', 'Leading points unavailable');
    }

    // primary game: live > last
    const primaryGame = schedule.liveGame || schedule.lastGame;
    const isLive = !!schedule.liveGame;

    // Next game summary (always)
    renderGameSummary(schedule.nextGame, 'nextGameBox');

    // "Most Recent Game" must be the game BEFORE the live/primary game
    const mostRecentBoxGame = schedule.prevFinalBefore || schedule.lastGame || null;
    renderGameSummary(mostRecentBoxGame, 'lastGameBox');

    // If no primary, hide live goals panel and stop.
    if (!primaryGame) {
      setGoalsVisibility(false);
      setTxt('state', 'No recent game');
      setTxt('score', '— — —');
      setTxt('when', '—');
      setTxt('updated', '');
      setHTML('goals', '<div class="info">No recent games found. Check back during the hockey season!</div>');
      setHTML('lastGameGoals', '');
      return;
    }

    setGoalsVisibility(true);

    // Load details+boxscore for primary render
    const [details, boxscore] = await Promise.all([
      getGameDetails(primaryGame.id),
      getGameBoxscore(primaryGame.id).catch(()=>null)
    ]);

    renderScorebar(primaryGame, details, boxscore);
    renderGoals(details, 'goals', true); // newest-first
    setUpdatedNow();

    // Most Recent Game scoring details (game BEFORE live/primary)
    if (mostRecentBoxGame?.id) {
      try {
        const lastDetails = await getGameDetails(mostRecentBoxGame.id);
        renderGoals(lastDetails, 'lastGameGoals', true);
      } catch {
        setHTML('lastGameGoals', '');
      }
    } else {
      setHTML('lastGameGoals', '');
    }

    // If live: auto-refresh
    if (isLive) {
      const gameId = primaryGame.id;
      const refreshInterval = setInterval(async () => {
        try {
          const [updatedDetails, updatedBox] = await Promise.all([
            getGameDetails(gameId),
            getGameBoxscore(gameId).catch(()=>null)
          ]);

          const gameState = updatedDetails?.gameState;
          renderScorebar(primaryGame, updatedDetails, updatedBox);
          renderGoals(updatedDetails, 'goals', true);
          setUpdatedNow();

          if (['FINAL', 'OFF'].includes(gameState)) {
            clearInterval(refreshInterval);
            setTimeout(() => location.reload(), 2000);
          }
        } catch (e) {
          console.error('Refresh error:', e);
        }
      }, 15000);
    }

  } catch (error) {
    console.error('Error loading data:', error);
    setTxt('state', 'Error loading data');
    setTxt('when', '—');
    setTxt('updated', '');
    setHTML('goals', `<div class="error">Unable to load NHL data. This widget uses a CORS proxy which may be rate-limited.</div>`);
    setHTML('lastGameBox', '<div class="error">—</div>');
    setHTML('nextGameBox', '<div class="error">—</div>');
    setHTML('lastGameGoals', '');
    setHTML('standingLine', 'Standings position unavailable');
    setHTML('formStreakLine', 'Form unavailable');
  }
})();
</script>

</body>
</html>
