<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Buffalo Sabres — Scores & Goals</title>
<style>
  :root{
    --sabres-navy: #002654;
    --sabres-gold: #FCB514;
    --sabres-white: #f7f9fc;
    --bg-deep: #001631;
  }
  *{box-sizing:border-box; margin:0; padding:0}
  html,body{height:100%; min-height:100vh}
  body{
    color:var(--sabres-white);
    background:
      radial-gradient(1200px 700px at 80% 10%, rgba(252,181,20,.12), transparent 60%),
      radial-gradient(900px 500px at 20% 80%, rgba(0,38,84,.35), transparent 70%),
      var(--bg-deep);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
    padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  .wrap{
    max-width:1200px;
    width:100%;
    margin:0 auto;
    padding:28px clamp(16px, 3vw, 36px);
  }

  /* Team Header */
  .team-header{
    position:relative;
    text-align:center;
    margin-bottom:24px;
    padding:24px 20px;
    background: linear-gradient(180deg, rgba(0,38,84,.65), rgba(0,28,62,.65));
    border: 2px solid rgba(252,181,20,.25);
    border-radius:18px;
    box-shadow: 0 8px 24px rgba(0,0,0,.3);
    overflow:hidden;
  }

  /* Slug images (large, centered on sides) */
  .slug{
    position:absolute;
    top:50%;
    transform:translateY(-50%);
    height:200px;
    width:auto;
    opacity:.92;
    pointer-events:none;

    filter:
      drop-shadow(0 12px 20px rgba(0,0,0,.45))
      drop-shadow(0 0 10px rgba(252,181,20,.18))
      drop-shadow(0 0 2px rgba(255,255,255,.12));
  }
  .slug-left{ left:18px; }
  .slug-right{ right:18px; transform:translateY(-50%) scaleX(-1); }

  .team-header-inner{
    position:relative;
    z-index:1;
    max-width:820px;
    margin:0 auto;
    padding:0 240px; /* prevent overlap with big slugs */
  }

  .header-logo{
    display:block;
    margin:0 auto 12px;
    max-width:min(520px, 86vw);
    height:auto;
    image-rendering:auto;
    filter: drop-shadow(0 8px 16px rgba(0,0,0,.35));
  }

  .team-stats{
    display:flex;
    justify-content:center;
    gap:32px;
    flex-wrap:wrap;
    margin-top:6px;
  }

  .stat-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:4px;
  }

  .stat-label{
    font-size:.9rem;
    color:#a8c5f5;
    font-weight:600;
    text-transform:uppercase;
    letter-spacing:.5px;
  }

  .stat-value{
    font-size:1.25rem;
    color:var(--sabres-gold);
    font-weight:800;
  }

  .top-scorer{
    margin-top:12px;
    padding-top:12px;
    border-top:1px solid rgba(252,181,20,.2);
    color:#cfe1ff;
    font-size:1.05rem;
  }

  .top-scorer strong{
    color:var(--sabres-gold);
    font-weight:800;
  }

  /* Score header */
  .scorebar{
    display:flex;
    flex-direction:column;
    gap:14px;
    background: linear-gradient(180deg, rgba(0,38,84,.85), rgba(0,28,62,.85));
    border: 2px solid rgba(252,181,20,.35);
    border-radius:18px;
    padding:18px 20px;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
  }

  .score-top{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center;
    gap:16px;
    min-width:0;
  }

  .team{
    display:flex;
    flex-direction:column;
    gap:8px;
    min-width:0;
  }

  .team.away{ align-items:flex-end; text-align:right; }
  .team.home{ align-items:flex-start; text-align:left; }

  .team-name-row{
    display:flex;
    align-items:center;
    gap:12px;
    min-width:0;
  }
  .team.away .team-name-row{ justify-content:flex-end; }
  .team.home .team-name-row{ justify-content:flex-start; }

  .badge{
    width:64px;
    height:64px;
    border-radius:12px;
    background-size:contain;
    background-position:center;
    background-repeat:no-repeat;
    border:2px solid rgba(252,181,20,.3);
    flex-shrink:0;
  }

  .name{
    font-weight:900;
    letter-spacing:.3px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    font-size:1.18rem;
  }

  .team-metrics{
    display:grid;
    gap:4px;
    color:#cfe1ff;
    font-size:.95rem;
    opacity:.95;
  }
  .metric b{ color:#ffe9b3; font-weight:900; }
  .metric span{ color:#cfe1ff; }

  .center-stack{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    min-width:210px;
  }

  .score{
    font-weight:900;
    font-size:2.6rem;
    color:var(--sabres-gold);
    white-space:nowrap;
    line-height:1.05;
  }

  .mid-meta{
    text-align:center;
    color:#cfe1ff;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .state{
    font-weight:900;
    font-size:1.05rem;
  }
  .pill{
    display:inline-block;
    font-size:.9rem;
    padding:5px 12px;
    border-radius:999px;
    background: rgba(252,181,20,.18);
    border:1px solid rgba(252,181,20,.35);
    color:#ffe9b3;
    font-weight:900;
  }
  .muted{
    font-size:.85rem;
    opacity:.75;
  }

  .chip{
    display:inline-block;
    padding:2px 10px;
    border-radius:999px;
    border:1px solid rgba(252,181,20,.25);
    background: rgba(255,255,255,.05);
    font-weight:900;
    letter-spacing:.2px;
    margin:0 3px 0 0;
  }
  .chip.w{ color:#bff7c0; border-color: rgba(191,247,192,.25); }
  .chip.l{ color:#ffb3b3; border-color: rgba(255,179,179,.25); }

  /* Panels */
  .panel{
    margin-top:20px;
    background: linear-gradient(180deg, rgba(0,38,84,.72), rgba(0,28,62,.72));
    border: 1px solid rgba(252,181,20,.28);
    border-radius:16px;
    padding:18px 20px;
  }

  .panel h3{
    margin:0 0 14px 0;
    font-size:1.15rem;
    color:#ffe9b3;
    border-bottom:1px solid rgba(252,181,20,.2);
    padding-bottom:8px;
  }

  .game-summary{
    display:flex;
    flex-direction:column;
    gap:8px;
    font-size:1rem;
  }

  .game-summary strong{
    color:var(--sabres-gold);
    font-weight:900;
  }

  /* Goals list */
  .goals{
    display:grid;
    gap:12px;
    margin-top:14px;
  }

  .goal{
    display:grid;
    grid-template-columns: 110px 1fr;
    gap:14px;
    align-items:start;
    padding:12px 14px;
    border-radius:12px;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(252,181,20,.15);
    transition:all .2s;
  }

  .goal:hover{
    background: rgba(252,181,20,.08);
    border-color:rgba(252,181,20,.3);
  }

  .time{
    font-weight:900;
    color:#ffe3a3;
    font-size:.95rem;
  }

  .goal-details{
    display:flex;
    flex-direction:column;
    gap:4px;
  }

  .who{
    font-weight:900;
    color:var(--sabres-white);
  }

  .team-name{
    color:var(--sabres-gold);
    font-weight:900;
  }

  .assist{
    color:#c6d6f6;
    font-size:.92rem;
    margin-top:2px;
  }

  .assist-player{
    display:inline-block;
    margin-right:8px;
  }

  .sep{
    opacity:.4;
    padding:0 6px;
  }

  .strength{
    color:#a8c5f5;
    font-size:.85rem;
    font-weight:900;
  }

  .loading, .error, .info{
    text-align:center;
    padding:20px;
    color:#c6d6f6;
  }

  .error{
    color:#ff9999;
  }

  .info{
    color:#a8c5f5;
    font-size:.95rem;
    line-height:1.6;
  }

  /* Mobile safeguards */
  @media (max-width: 980px){
    .team-header-inner{ padding:0 200px; }
    .slug{ height:170px; }
  }
  @media (max-width:768px){
    .team-header-inner{ padding:0 96px; }
    .slug{ height:120px; opacity:.65; }
    .slug-left{ left:10px; }
    .slug-right{ right:10px; }

    .score-top{
      grid-template-columns: 1fr;
      gap:14px;
    }

    .team.away, .team.home{
      align-items:center;
      text-align:center;
    }
    .team.away .team-name-row,
    .team.home .team-name-row{
      justify-content:center;
    }

    .center-stack{
      min-width:auto;
    }

    .score{ font-size:2.2rem; }

    .goal{
      grid-template-columns: 96px 1fr;
      gap:10px;
    }
  }

  @media (max-width:480px){
    .team-header-inner{ padding:0 18px; }
    .slug{ display:none; }

    .badge{ width:56px; height:56px; }
    .name{ font-size:1.05rem; }
    .score{ font-size:2rem; }

    .header-logo{ max-width:92vw; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Team Header -->
    <div class="team-header">
      <img class="slug slug-left" src="slug.png" alt="" aria-hidden="true">
      <img class="slug slug-right" src="slug.png" alt="" aria-hidden="true">

      <div class="team-header-inner">
        <img class="header-logo" src="sabres2.png?v=123" alt="Buffalo Sabres">

        <div class="team-stats">
          <div class="stat-item">
            <span class="stat-label">Record</span>
            <span class="stat-value" id="record">—</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Points</span>
            <span class="stat-value" id="points">—</span>
          </div>
        </div>

        <!-- NEW: last 5 + streak (below record/points, above standings) -->
        <div class="top-scorer" id="formLine" style="margin-top:10px; border-top:1px solid rgba(252,181,20,.2);">
          Loading last 5…
        </div>
        <div class="top-scorer" id="streakLine" style="margin-top:8px; border-top:none; padding-top:0;">
          Loading streak…
        </div>

        <!-- standings line -->
        <div class="top-scorer" id="standingLine" style="margin-top:10px; border-top:1px solid rgba(252,181,20,.2);">
          Loading standings…
        </div>

        <!-- leaders -->
        <div class="top-scorer" id="topGoals">Loading leading goals...</div>
        <div class="top-scorer" id="topPoints" style="margin-top:8px; border-top:none; padding-top:0;">
          Loading leading points...
        </div>
      </div>
    </div>

    <!-- Primary score bar -->
    <div class="scorebar" id="scorebar">
      <div class="score-top">
        <!-- Away -->
        <div class="team away" id="awayTeam">
          <div class="team-name-row">
            <div class="name">Away</div>
            <div class="badge" id="awayBadge"></div>
          </div>

          <div class="team-metrics" id="awayMetrics">
            <div class="metric"><b>SOG</b>: <span id="awaySog">—</span></div>
            <div class="metric"><b>Hits</b>: <span id="awayHits">—</span></div>
            <div class="metric"><b>Blk</b>: <span id="awayBlocks">—</span></div>
            <div class="metric"><b>G</b>: <span id="awayGoalie">—</span></div>
          </div>
        </div>

        <!-- Center -->
        <div class="center-stack">
          <div class="score" id="score">— — —</div>
          <div class="mid-meta">
            <div class="state" id="state">Loading…</div>
            <div><span class="pill" id="when"></span></div>
            <div class="muted" id="updated"></div>
          </div>
        </div>

        <!-- Home -->
        <div class="team home" id="homeTeam">
          <div class="team-name-row">
            <div class="badge" id="homeBadge"></div>
            <div class="name">Home</div>
          </div>

          <div class="team-metrics" id="homeMetrics">
            <div class="metric"><b>SOG</b>: <span id="homeSog">—</span></div>
            <div class="metric"><b>Hits</b>: <span id="homeHits">—</span></div>
            <div class="metric"><b>Blk</b>: <span id="homeBlocks">—</span></div>
            <div class="metric"><b>G</b>: <span id="homeGoalie">—</span></div>
          </div>
        </div>
      </div>

      <div class="panel" id="liveGoalsPanel" style="margin-top:0;">
        <h3>Goals</h3>
        <div class="goals" id="goals"><div class="loading">Loading goals…</div></div>
      </div>
    </div>

    <div class="panel" id="lastGamePanel">
      <h3>Most Recent Game</h3>
      <div id="lastGameBox" class="loading">Loading…</div>
      <div class="goals" id="lastGameGoals"></div>
    </div>

    <div class="panel" id="nextGamePanel">
      <h3>Next Game</h3>
      <div id="nextGameBox" class="loading">Loading…</div>
    </div>
  </div>

<script>
(async function(){
  const SABRES_ABBR = 'BUF';
  const CORS_PROXY = 'https://corsproxy.io/?';

  // Helper functions
  const setTxt = (id, t) => {
    const el = document.getElementById(id);
    if (el) el.textContent = t;
  };

  const setHTML = (id, html) => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  };

  function formatDate(dateStr) {
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        timeZone: 'America/New_York',
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    } catch {
      return dateStr;
    }
  }

  function getTeamLogo(abbr) {
    return `https://assets.nhle.com/logos/nhl/svg/${abbr}_light.svg`;
  }

  function teamLabel(t) {
    return t?.placeName?.default
        || t?.commonName?.default
        || t?.name?.default
        || t?.abbrev
        || '';
  }

  function setUpdatedNow() {
    const el = document.getElementById('updated');
    if (!el) return;
    el.textContent = `Updated ${new Date().toLocaleTimeString('en-US', {
      timeZone: 'America/New_York',
      hour: 'numeric',
      minute: '2-digit',
      second: '2-digit'
    })}`;
  }

  async function fetchJSON(url) {
    const proxiedUrl = CORS_PROXY + encodeURIComponent(url);
    const response = await fetch(proxiedUrl, { cache: 'no-store' });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  }

  // --- existing helpers (kept) ---
  function deepGet(obj, path) {
    try {
      return path.split('.').reduce((acc, k) => (acc == null ? undefined : acc[k]), obj);
    } catch {
      return undefined;
    }
  }

  function firstDefined(...vals) {
    for (const v of vals) {
      if (v !== undefined && v !== null) return v;
    }
    return undefined;
  }
  // -------------------------------

  // NEW: recursive numeric search (handles wildly inconsistent boxscore shapes)
  function scanForNumeric(obj, keys, maxDepth = 5, depth = 0, seen = new Set()) {
    if (!obj || typeof obj !== 'object') return null;
    if (seen.has(obj)) return null;
    seen.add(obj);

    // direct keys
    for (const k of keys) {
      if (obj[k] !== undefined && obj[k] !== null) {
        const n = Number(obj[k]);
        if (Number.isFinite(n)) return n;
      }
    }

    if (depth >= maxDepth) return null;

    // walk children
    for (const v of Object.values(obj)) {
      if (!v) continue;
      if (typeof v === 'object') {
        const found = scanForNumeric(v, keys, maxDepth, depth + 1, seen);
        if (found !== null) return found;
      }
    }
    return null;
  }

  // NEW: recursive string/number search for sv% (may be ".912", "0.912", "91.2", etc.)
  function scanForValue(obj, keys, maxDepth = 5, depth = 0, seen = new Set()) {
    if (!obj || typeof obj !== 'object') return null;
    if (seen.has(obj)) return null;
    seen.add(obj);

    for (const k of keys) {
      if (obj[k] !== undefined && obj[k] !== null) return obj[k];
    }
    if (depth >= maxDepth) return null;

    for (const v of Object.values(obj)) {
      if (!v) continue;
      if (typeof v === 'object') {
        const found = scanForValue(v, keys, maxDepth, depth + 1, seen);
        if (found !== null) return found;
      }
    }
    return null;
  }

  // Get team standings and stats (record + points)
  async function getTeamStats() {
    try {
      const url = `https://api-web.nhle.com/v1/standings/now`;
      const data = await fetchJSON(url);

      let sabres = null;
      for (const standing of data.standings || []) {
        if (standing.teamAbbrev?.default === SABRES_ABBR) {
          sabres = standing;
          break;
        }
      }
      if (!sabres) return { wins: 0, losses: 0, otLosses: 0, points: 0 };

      return {
        wins: sabres.wins || 0,
        losses: sabres.losses || 0,
        otLosses: sabres.otLosses || 0,
        points: sabres.points || 0
      };
    } catch {
      return null;
    }
  }

  // conference/division/league ranks
  async function getSabresStandingsPosition() {
    try {
      const url = `https://api-web.nhle.com/v1/standings/now`;
      const data = await fetchJSON(url);

      let sabres = null;
      for (const standing of data.standings || []) {
        if (standing.teamAbbrev?.default === SABRES_ABBR) {
          sabres = standing;
          break;
        }
      }
      if (!sabres) return null;

      const conference = sabres.conferenceName || sabres.conferenceAbbrev || sabres.conference || (sabres.conferenceName?.default ?? null);
      const conferenceRank = sabres.conferenceSequence ?? sabres.conferenceRank ?? sabres.conferencePlace ?? sabres.conferenceStanding ?? null;

      const division = sabres.divisionName || sabres.divisionAbbrev || sabres.division || (sabres.divisionName?.default ?? null);
      const divisionRank = sabres.divisionSequence ?? sabres.divisionRank ?? sabres.divisionPlace ?? sabres.divisionStanding ?? null;

      const leagueRank = sabres.leagueSequence ?? sabres.leagueRank ?? sabres.leaguePlace ?? sabres.leagueStanding ?? null;

      const confLabel =
        (typeof conference === 'string' && conference.trim()) ? conference :
        (sabres.conferenceAbbrev?.default || sabres.conferenceName?.default || sabres.conference || 'Conference');

      return {
        conference: confLabel,
        conferenceRank: conferenceRank ?? '—',
        division: (typeof division === 'string' && division.trim()) ? division : (sabres.divisionAbbrev?.default || sabres.divisionName?.default || sabres.division || 'Division'),
        divisionRank: divisionRank ?? '—',
        leagueRank: leagueRank ?? '—'
      };
    } catch {
      return null;
    }
  }

  // Get roster and find leaders (goals + points)
  async function getLeaders() {
    try {
      const url = `https://api-web.nhle.com/v1/club-stats/${SABRES_ABBR}/now`;
      const data = await fetchJSON(url);

      const skaters = data.skaters || [];
      if (!skaters.length) return null;

      const bestGoals = skaters.reduce((best, p) => (p.goals||0) > (best.goals||0) ? p : best, skaters[0]);
      const bestPoints = skaters.reduce((best, p) => (p.points||0) > (best.points||0) ? p : best, skaters[0]);

      const name = (p) => `${p.firstName?.default || ''} ${p.lastName?.default || ''}`.trim();

      return {
        goals: { name: name(bestGoals), val: bestGoals.goals || 0 },
        points: { name: name(bestPoints), val: bestPoints.points || 0 }
      };
    } catch {
      return null;
    }
  }

  // CHANGED: fetch multiple weeks back so "last 5" and streak are real (not limited to 2 weeks)
  async function getSchedule() {
    const now = new Date();
    const formatAPIDate = (d) => d.toISOString().split('T')[0];

    const weeksBack = 8; // enough coverage for last 5 finals + streak reliably
    const weekDates = [];
    for (let i = 0; i <= weeksBack; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - (7 * i));
      weekDates.push(d);
    }

    const urls = weekDates.map(d => `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${formatAPIDate(d)}`);
    const results = await Promise.all(urls.map(u => fetchJSON(u).catch(() => ({ games: [] }))));

    // merge + de-dupe by game id
    const gameMap = new Map();
    for (const r of results) {
      for (const g of (r.games || [])) {
        if (g?.id != null) gameMap.set(g.id, g);
      }
    }
    const allGames = Array.from(gameMap.values());

    const liveGame = allGames.find(g =>
      g.gameState === 'LIVE' ||
      g.gameState === 'CRIT' ||
      g.gameState === 'CRITICAL'
    );

    const finalsSorted = allGames
      .filter(g => (g.gameState === 'OFF' || g.gameState === 'FINAL'))
      .sort((a,b) => new Date(b.startTimeUTC) - new Date(a.startTimeUTC));

    const lastGame = finalsSorted[0];

    const prevFinalBefore = (() => {
      if (liveGame) {
        const liveStart = new Date(liveGame.startTimeUTC).getTime();
        return finalsSorted.find(g => new Date(g.startTimeUTC).getTime() < liveStart) || null;
      }
      return finalsSorted.length > 1 ? finalsSorted[1] : null;
    })();

    const nextGame = allGames
      .filter(g => g.gameState === 'FUT' || g.gameState === 'PRE')
      .sort((a, b) => new Date(a.startTimeUTC) - new Date(b.startTimeUTC))[0];

    return { liveGame, lastGame, prevFinalBefore, nextGame, games: allGames, finalsSorted };
  }

  // Get game details with cache buster
  async function getGameDetails(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/play-by-play?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  // Boxscore for SOG/Hits/Blocks/Goalie sv%
  async function getGameBoxscore(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/boxscore?cb=${Date.now()}`;
    return await fetchJSON(url);
  }

  // Save% formatting: .XXX (standard)
  function formatSavePctDot(v) {
    if (v == null) return '—';
    const s = (typeof v === 'string') ? v.trim().replace('%','') : v;
    let num = (typeof s === 'number') ? s : Number(s);
    if (!Number.isFinite(num)) return '—';
    if (num > 1.5) num = num / 100; // percent -> decimal
    // if already like ".912" parse gives 0.912, good
    return `.${String(Math.round(num * 1000)).padStart(3,'0')}`;
  }

  // More robust goalie label: try sv% keys; else compute from saves/shots keys (including deep scan)
  function goalieLabel(g) {
    if (!g) return '—';

    const ln = g.lastName?.default || g.lastName || '';
    const name = ln ? ln : (g.name?.default || g.name || 'Goalie');

    const svRaw =
      g.savePctg ?? g.savePercentage ?? g.savePct ?? g.svPct ?? g.savePctgDecimal ??
      g.savePctgValue ?? g.savePctValue ?? g.savePctgDisplay ?? g.svPctg ?? null;

    if (svRaw != null) return `${name} (${formatSavePctDot(svRaw)})`;

    // Deep scan for any sv% key the API might hide
    const svDeep = scanForValue(g, ['savePctg','savePercentage','savePct','svPct','svPctg','savePctgDecimal','savePctValue','savePctgValue'], 4);
    if (svDeep != null) return `${name} (${formatSavePctDot(svDeep)})`;

    // Compute from saves/shots (deep scan)
    const saves = firstDefined(
      g.saves, g.save, g.totalSaves, g.savesAgainst, g.numSaves, g.sv, g.svTotal,
      scanForNumeric(g, ['saves','totalSaves','savesAgainst','numSaves','sv'], 4)
    );
    const shotsAgainst = firstDefined(
      g.shotsAgainst, g.shotsFaced, g.shots, g.sa, g.shotsOnGoalAgainst, g.totalShotsAgainst,
      scanForNumeric(g, ['shotsAgainst','shotsFaced','shots','sa','shotsOnGoalAgainst','totalShotsAgainst'], 4)
    );

    const sNum = Number(saves);
    const saNum = Number(shotsAgainst);
    if (Number.isFinite(sNum) && Number.isFinite(saNum) && saNum > 0) {
      return `${name} (${formatSavePctDot(sNum / saNum)})`;
    }

    return `${name} (—)`;
  }

  // goalie selection prioritizes playerByGameStats
  function findLikelyGoalie(side, box) {
    const pgStats = box?.playerByGameStats;
    if (pgStats) {
      const teamStats = (side === 'away') ? pgStats.awayTeam : pgStats.homeTeam;
      const goalies = teamStats?.goalies;
      if (Array.isArray(goalies) && goalies.length > 0) return goalies[0];
    }

    const t = (side === 'away') ? (box?.awayTeam || box?.away) : (box?.homeTeam || box?.home);
    if (t?.goalies && Array.isArray(t.goalies) && t.goalies.length > 0) return t.goalies[0];

    const allPlayers = t?.players || t?.roster || [];
    if (Array.isArray(allPlayers) && allPlayers.length) {
      const goalie = allPlayers.find(p => ((p.positionCode || p.position || '').toString().toUpperCase() === 'G'));
      if (goalie) return goalie;
    }

    // Deep scan for a goalie-like object (rare, but some shapes bury it)
    const subtree = (side === 'away') ? (pgStats?.awayTeam || t || null) : (pgStats?.homeTeam || t || null);
    if (subtree) {
      // try to find an object that has positionCode === 'G'
      const found = (function scanForGoalie(obj, depth = 0, seen = new Set()) {
        if (!obj || typeof obj !== 'object') return null;
        if (seen.has(obj)) return null;
        seen.add(obj);
        if (String(obj.positionCode || obj.position || '').toUpperCase() === 'G') return obj;
        if (depth > 5) return null;
        for (const v of Object.values(obj)) {
          if (typeof v === 'object' && v) {
            const r = scanForGoalie(v, depth + 1, seen);
            if (r) return r;
          }
        }
        return null;
      })(subtree);
      if (found) return found;
    }

    return null;
  }

  // Keep old extractor (not removed)
  function extractTeamStatOld(side, box, statName) {
    const sideKey = side === 'away' ? 'awayTeam' : 'homeTeam';
    const t = (side === 'away') ? (box?.awayTeam || box?.away) : (box?.homeTeam || box?.home);

    const keysByStat = {
      sog:   ['shotsOnGoal', 'sog', 'shots', 'shotsOnNet'],
      hits:  ['hits', 'hitCount'],
      blocks:['blockedShots', 'blocks', 'blocked', 'shotsBlocked', 'blockedShotCount'],
    };
    const keys = keysByStat[statName] || [];

    const roots = [
      t,
      t?.teamStats,
      t?.teamSkaterStats,
      t?.statistics,
      (side === 'away' ? box?.playerByGameStats?.awayTeam?.teamSkaterStats : box?.playerByGameStats?.homeTeam?.teamSkaterStats),
      (side === 'away' ? box?.awayTeam?.teamStats : box?.homeTeam?.teamStats),
      (side === 'away' ? box?.awayTeam?.teamSkaterStats : box?.homeTeam?.teamSkaterStats),
    ];

    for (const r of roots) {
      if (!r) continue;
      for (const k of keys) {
        if (r[k] !== undefined && r[k] !== null) return r[k];
      }
    }

    const deepPaths = {
      sog: [
        `${sideKey}.shotsOnGoal`,
        `${sideKey}.teamStats.shotsOnGoal`,
        `playerByGameStats.${sideKey}.teamSkaterStats.shotsOnGoal`,
        `playerByGameStats.${sideKey}.teamSkaterStats.sog`,
      ],
      hits: [
        `${sideKey}.hits`,
        `${sideKey}.teamStats.hits`,
        `playerByGameStats.${sideKey}.teamSkaterStats.hits`,
      ],
      blocks: [
        `${sideKey}.blockedShots`,
        `${sideKey}.teamStats.blockedShots`,
        `playerByGameStats.${sideKey}.teamSkaterStats.blockedShots`,
        `playerByGameStats.${sideKey}.teamSkaterStats.blocks`,
      ]
    };

    for (const p of (deepPaths[statName] || [])) {
      const v = deepGet(box, p);
      if (v !== undefined && v !== null) return v;
    }

    return null;
  }

  // CHANGED: team stat extraction now tries multiple known containers + deep scan per-side
  function extractTeamStat(side, box, statName) {
    const pgStats = box?.playerByGameStats;
    const teamStats = pgStats ? ((side === 'away') ? pgStats.awayTeam : pgStats.homeTeam) : null;
    const directTeam = (side === 'away') ? (box?.awayTeam || box?.away) : (box?.homeTeam || box?.home);

    const alias = {
      sog: ['sog','shotsOnGoal','shots','shotsOnNet'],
      hits: ['hits','hitCount'],
      blockedShots: ['blockedShots','blocks','blocked','shotsBlocked','blockedShotCount'],
    };
    const keys = alias[statName] || [statName];

    const candidates = [
      teamStats,
      teamStats?.teamStats,
      teamStats?.teamSkaterStats,
      teamStats?.statistics,
      directTeam,
      directTeam?.teamStats,
      directTeam?.teamSkaterStats,
      directTeam?.statistics,

      // additional shapes seen in some boxscores
      box?.teamGameStats,
      box?.teamGameStats?.[side],
      box?.teamGameStats?.[side === 'away' ? 'awayTeam' : 'homeTeam'],
      box?.summary,
      box?.summary?.teamGameStats,
      box?.summary?.teamGameStats?.[side],
      box?.summary?.teamGameStats?.[side === 'away' ? 'awayTeam' : 'homeTeam'],
      box?.gameStats,
      box?.gameStats?.[side],
      box?.gameStats?.[side === 'away' ? 'awayTeam' : 'homeTeam'],
    ];

    // direct search in candidates
    for (const obj of candidates) {
      if (!obj) continue;
      for (const k of keys) {
        if (obj[k] !== undefined && obj[k] !== null) {
          const n = Number(obj[k]);
          if (Number.isFinite(n)) return n;
          return obj[k];
        }
      }
    }

    // deep scan within side subtree first (prevents grabbing the other team's number)
    const sideSubtree = teamStats || directTeam || null;
    if (sideSubtree) {
      const found = scanForNumeric(sideSubtree, keys, 6);
      if (found !== null) return found;
    }

    // deep scan within likely per-side containers
    for (const obj of candidates) {
      if (!obj) continue;
      const found = scanForNumeric(obj, keys, 5);
      if (found !== null) return found;
    }

    // final fallback: old extractor
    const fallbackStatName = (statName === 'blockedShots') ? 'blocks' : statName;
    const vOld = extractTeamStatOld(side, box, fallbackStatName);
    return (vOld !== undefined && vOld !== null) ? vOld : null;
  }

  function applyTeamMetrics(side, box) {
    const sog = extractTeamStat(side, box, 'sog');
    const hits = extractTeamStat(side, box, 'hits');
    const blocks = extractTeamStat(side, box, 'blockedShots');

    const goalie = findLikelyGoalie(side, box);

    setTxt(side + 'Sog', sog != null ? String(sog) : '—');
    setTxt(side + 'Hits', hits != null ? String(hits) : '—');
    setTxt(side + 'Blocks', blocks != null ? String(blocks) : '—');
    setTxt(side + 'Goalie', goalieLabel(goalie));
  }

  function renderScorebar(game, details, boxscore) {
    if (!game) {
      setTxt('state', 'No game data');
      setTxt('when', '—');
      return;
    }

    const away = details?.awayTeam || game.awayTeam;
    const home = details?.homeTeam || game.homeTeam;

    document.querySelector('#awayTeam .name').textContent = teamLabel(away);
    document.querySelector('#homeTeam .name').textContent = teamLabel(home);

    const awayAbbrev = away.abbrev || game.awayTeam?.abbrev;
    const homeAbbrev = home.abbrev || game.homeTeam?.abbrev;

    document.getElementById('awayBadge').style.backgroundImage = `url('${getTeamLogo(awayAbbrev)}')`;
    document.getElementById('homeBadge').style.backgroundImage = `url('${getTeamLogo(homeAbbrev)}')`;

    const awayScore = details?.awayTeam?.score ?? game.awayTeam?.score ?? 0;
    const homeScore = details?.homeTeam?.score ?? game.homeTeam?.score ?? 0;
    setTxt('score', `${awayScore} — ${homeScore}`);

    const gameState = details?.gameState || game.gameState;
    const isLive = ['LIVE', 'CRIT', 'CRITICAL'].includes(gameState);

    let status = 'Final';
    if (isLive) {
      status = 'LIVE';
      if (details?.periodDescriptor) {
        const period = details.periodDescriptor.number;
        const periodType = details.periodDescriptor.periodType;
        if (periodType === 'OT') status = 'OVERTIME';
        else if (periodType === 'SO') status = 'SHOOTOUT';
        else status = `${period}${period === 1 ? 'st' : period === 2 ? 'nd' : period === 3 ? 'rd' : 'th'} Period`;
      }
      if (details?.clock?.inIntermission) status = 'Intermission';
    } else if (['FUT', 'PRE'].includes(gameState)) status = 'Scheduled';
    else if (['FINAL', 'OFF'].includes(gameState)) status = 'Final';

    setTxt('state', status);

    let when = '';
    if (isLive) {
      if (details?.clock?.inIntermission) {
        const ir =
          details.clock.intermissionTimeRemaining ||
          details.clock.intermissionRemaining ||
          details.clock.intermissionTimeRemainingSeconds ||
          details.clock.intermissionTimeLeft;

        if (typeof ir === 'string' && ir.trim()) when = `INT ${ir}`;
        else if (typeof ir === 'number' && Number.isFinite(ir)) {
          const mm = Math.floor(ir / 60);
          const ss = String(ir % 60).padStart(2, '0');
          when = `INT ${mm}:${ss}`;
        } else {
          when = 'Intermission';
        }
      } else {
        when = details?.clock?.timeRemaining || '';
      }
    } else {
      when = formatDate(game.startTimeUTC);
    }
    setTxt('when', when || '—');

    if (boxscore) {
      applyTeamMetrics('away', boxscore);
      applyTeamMetrics('home', boxscore);
    } else {
      ['awaySog','homeSog','awayHits','homeHits','awayBlocks','homeBlocks','awayGoalie','homeGoalie'].forEach(id => setTxt(id, '—'));
    }
  }

  function buildPlayerMap(details) {
    const playerMap = new Map();
    const roster = details?.rosterSpots || [];
    for (const p of roster) {
      if (!p?.playerId) continue;
      const nm = `${p.firstName?.default || ''} ${p.lastName?.default || ''}`.trim();
      playerMap.set(p.playerId, nm);
    }
    return playerMap;
  }

  function timeToSec(t) {
    if (!t) return 0;
    const parts = String(t).split(':');
    const mm = parseInt(parts[0] || '0', 10);
    const ss = parseInt(parts[1] || '0', 10);
    return (mm * 60) + ss;
  }

  function renderGoals(details, containerId, newestFirst = true) {
    const goalsEl = document.getElementById(containerId);
    if (!goalsEl) return;

    if (!details) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const plays = details.plays || details.gameEvents || [];
    if (!plays || !plays.length) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const playerMap = buildPlayerMap(details);

    let goals = plays
      .filter(p => p.typeDescKey === 'goal' || p.typeCode === 'GOAL')
      .filter(p => p.periodDescriptor?.periodType !== 'SO');

    if (!goals.length) {
      goalsEl.innerHTML = '<div class="loading">No goals scored yet</div>';
      return;
    }

    goals.sort((a,b) => {
      const pd = (a.periodDescriptor?.number || 0) - (b.periodDescriptor?.number || 0);
      if (pd !== 0) return pd;
      return timeToSec(a.timeInPeriod) - timeToSec(b.timeInPeriod);
    });
    if (newestFirst) goals.reverse();

    let html = '';
    for (const goal of goals) {
      const period = goal.periodDescriptor?.number || '';
      const time = goal.timeInPeriod || '';
      const teamId = goal.details?.eventOwnerTeamId;

      const teamInfo = (details.homeTeam?.id === teamId) ? details.homeTeam : details.awayTeam;
      const tName = teamLabel(teamInfo);

      let scorerName = 'Unknown';
      let goalNumber = '';

      if (goal.details) {
        const scorerId = goal.details.scoringPlayerId || goal.details.playerId;
        if (scorerId && playerMap.has(scorerId)) scorerName = playerMap.get(scorerId);
        else if (goal.details.scoringPlayer) scorerName = goal.details.scoringPlayer;
        if (goal.details.scoringPlayerTotal) goalNumber = ` (${goal.details.scoringPlayerTotal})`;
      }

      const assists = [];
      if (goal.details) {
        const a1 = goal.details.assist1PlayerId;
        if (a1 && playerMap.has(a1)) {
          assists.push(`${playerMap.get(a1)}${goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : ''}`);
        } else if (goal.details.assist1Player) {
          assists.push(`${goal.details.assist1Player}${goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : ''}`);
        }

        const a2 = goal.details.assist2PlayerId;
        if (a2 && playerMap.has(a2)) {
          assists.push(`${playerMap.get(a2)}${goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : ''}`);
        } else if (goal.details.assist2Player) {
          assists.push(`${goal.details.assist2Player}${goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : ''}`);
        }
      }

      const strength = goal.details?.strength || 'ev';
      const situation = goal.details?.situationCode || '';

      html += `
        <div class="goal">
          <div class="time">P${period}<br>${time}</div>
          <div class="goal-details">
            <div>
              <span class="team-name">${tName}</span>
              <span class="sep">—</span>
              <span class="who">${scorerName}${goalNumber}</span>
            </div>
            <div class="strength">${String(strength).toUpperCase()}${situation ? ` (${situation})` : ''}</div>
            ${assists.length ? `<div class="assist">Assists: ${assists.map(a => `<span class="assist-player">${a}</span>`).join('')}</div>` : ''}
          </div>
        </div>
      `;
    }

    goalsEl.innerHTML = html;
  }

  function renderGameSummary(game, targetId) {
    const el = document.getElementById(targetId);
    if (!el) return;

    if (!game) {
      el.innerHTML = '<div class="loading">No game data</div>';
      return;
    }

    const away = game.awayTeam;
    const home = game.homeTeam;
    const when = formatDate(game.startTimeUTC);

    el.innerHTML = `
      <div class="game-summary">
        <div><strong>${teamLabel(away)}</strong> at <strong>${teamLabel(home)}</strong></div>
        <div>${(game.gameState === 'OFF' || game.gameState === 'FINAL') ? `Final: ${away.score || 0} — ${home.score || 0}` : ''}</div>
        <div>${when}</div>
      </div>
    `;
  }

  function setGoalsVisibility(show) {
    const liveGoalsPanel = document.getElementById('liveGoalsPanel');
    if (!liveGoalsPanel) return;
    liveGoalsPanel.style.display = show ? '' : 'none';
  }

  // NEW: compute last 5 + streak from finalsSorted
  function computeFormAndStreak(finalsSorted) {
    const finals = (finalsSorted || []).slice(); // already newest-first
    if (!finals.length) return { last5: null, streak: null };

    const last5Games = finals.slice(0, 5);
    const results = last5Games.map(g => {
      const isHome = (g.homeTeam?.abbrev === SABRES_ABBR);
      const bufScore = isHome ? (g.homeTeam?.score ?? 0) : (g.awayTeam?.score ?? 0);
      const oppScore = isHome ? (g.awayTeam?.score ?? 0) : (g.homeTeam?.score ?? 0);
      return (bufScore > oppScore) ? 'W' : 'L';
    });

    // streak from most recent final
    const first = results[0];
    let streakCount = 0;
    for (const g of finals) {
      const isHome = (g.homeTeam?.abbrev === SABRES_ABBR);
      const bufScore = isHome ? (g.homeTeam?.score ?? 0) : (g.awayTeam?.score ?? 0);
      const oppScore = isHome ? (g.awayTeam?.score ?? 0) : (g.homeTeam?.score ?? 0);
      const r = (bufScore > oppScore) ? 'W' : 'L';
      if (r !== first) break;
      streakCount++;
    }

    return {
      last5: results,
      streak: { type: first, count: streakCount }
    };
  }

  function renderFormAndStreak(finalsSorted) {
    const { last5, streak } = computeFormAndStreak(finalsSorted);

    if (last5 && last5.length) {
      const chips = last5.map(r => `<span class="chip ${r === 'W' ? 'w' : 'l'}">${r}</span>`).join('');
      setHTML('formLine', `Last 5: ${chips}`);
    } else {
      setHTML('formLine', 'Last 5: —');
    }

    if (streak && streak.count) {
      const label = streak.type === 'W' ? 'Win streak' : 'Losing streak';
      const cls = streak.type === 'W' ? 'w' : 'l';
      setHTML('streakLine', `Streak: <span class="chip ${cls}">${streak.type}${streak.count}</span> <span style="opacity:.85">(${label})</span>`);
    } else {
      setHTML('streakLine', 'Streak: —');
    }
  }

  // Main execution
  try {
    const schedule = await getSchedule();

    const teamStats = await getTeamStats().catch(()=>null);
    if (teamStats) {
      setTxt('record', `${teamStats.wins}-${teamStats.losses}-${teamStats.otLosses}`);
      setTxt('points', String(teamStats.points));
    } else {
      setTxt('record', '—');
      setTxt('points', '—');
    }

    // last 5 + streak (from expanded schedule coverage)
    renderFormAndStreak(schedule.finalsSorted || []);

    // standings line
    const pos = await getSabresStandingsPosition().catch(()=>null);
    if (pos) {
      setHTML(
        'standingLine',
        `Conference: <strong>${pos.conferenceRank}</strong> &nbsp; <span style="opacity:.8">|</span> &nbsp; Division: <strong>${pos.divisionRank}</strong> &nbsp; <span style="opacity:.8">|</span> &nbsp; League: <strong>${pos.leagueRank}</strong>`
      );
    } else {
      setHTML('standingLine', 'Standings position unavailable');
    }

    // leaders
    const leaders = await getLeaders().catch(()=>null);
    if (leaders) {
      setHTML('topGoals', `Leading goals: <strong>${leaders.goals.name}</strong>, ${leaders.goals.val}`);
      setHTML('topPoints', `Leading points: <strong>${leaders.points.name}</strong>, ${leaders.points.val}`);
    } else {
      setHTML('topGoals', 'Leading goals unavailable');
      setHTML('topPoints', 'Leading points unavailable');
    }

    // primary game: live > last
    const primaryGame = schedule.liveGame || schedule.lastGame;
    const isLive = !!schedule.liveGame;

    // Next game summary (always)
    renderGameSummary(schedule.nextGame, 'nextGameBox');

    // "Most Recent Game" must be the game BEFORE the live/primary game
    const mostRecentBoxGame = schedule.prevFinalBefore || schedule.lastGame || null;
    renderGameSummary(mostRecentBoxGame, 'lastGameBox');

    // If no primary, hide live goals panel and stop.
    if (!primaryGame) {
      setGoalsVisibility(false);
      setTxt('state', 'No recent game');
      setTxt('score', '— — —');
      setTxt('when', '—');
      setTxt('updated', '');
      setHTML('goals', '<div class="info">No recent games found. Check back during the hockey season!</div>');
      setHTML('lastGameGoals', '');
      return;
    }

    setGoalsVisibility(true);

    // Load details+boxscore for primary render
    const [details, boxscore] = await Promise.all([
      getGameDetails(primaryGame.id),
      getGameBoxscore(primaryGame.id).catch(()=>null)
    ]);

    // Debug block kept (you can comment out once verified)
    console.log('=== BOXSCORE STRUCTURE ===');
    console.log('Top keys:', Object.keys(boxscore || {}));
    console.log('Away team:', boxscore?.awayTeam);
    console.log('Home team:', boxscore?.homeTeam);
    console.log('PlayerByGameStats:', boxscore?.playerByGameStats);
    if (boxscore?.playerByGameStats?.awayTeam) {
      console.log('PGS Away goalies:', boxscore.playerByGameStats.awayTeam.goalies);
      console.log('PGS Away teamStats:', boxscore.playerByGameStats.awayTeam);
    }
    if (boxscore?.playerByGameStats?.homeTeam) {
      console.log('PGS Home goalies:', boxscore.playerByGameStats.homeTeam.goalies);
      console.log('PGS Home teamStats:', boxscore.playerByGameStats.homeTeam);
    }

    renderScorebar(primaryGame, details, boxscore);
    renderGoals(details, 'goals', true); // newest-first
    setUpdatedNow();

    // Most Recent Game scoring details (game BEFORE live/primary)
    if (mostRecentBoxGame?.id) {
      try {
        const lastDetails = await getGameDetails(mostRecentBoxGame.id);
        renderGoals(lastDetails, 'lastGameGoals', true);
      } catch {
        setHTML('lastGameGoals', '');
      }
    } else {
      setHTML('lastGameGoals', '');
    }

    // If live: auto-refresh
    if (isLive) {
      const gameId = primaryGame.id;
      const refreshInterval = setInterval(async () => {
        try {
          const [updatedDetails, updatedBox] = await Promise.all([
            getGameDetails(gameId),
            getGameBoxscore(gameId).catch(()=>null)
          ]);

          const gameState = updatedDetails?.gameState;
          renderScorebar(primaryGame, updatedDetails, updatedBox);
          renderGoals(updatedDetails, 'goals', true);
          setUpdatedNow();

          // keep last5/streak fresh in case a final just posted
          try {
            const sched2 = await getSchedule();
            renderFormAndStreak(sched2.finalsSorted || []);
          } catch {}

          if (['FINAL', 'OFF'].includes(gameState)) {
            clearInterval(refreshInterval);
            setTimeout(() => location.reload(), 2000);
          }
        } catch (e) {
          console.error('Refresh error:', e);
        }
      }, 15000);
    }

  } catch (error) {
    console.error('Error loading data:', error);
    setTxt('state', 'Error loading data');
    setTxt('when', '—');
    setTxt('updated', '');
    setHTML('goals', `<div class="error">Unable to load NHL data. This widget uses a CORS proxy which may be rate-limited.</div>`);
    setHTML('lastGameBox', '<div class="error">—</div>');
    setHTML('nextGameBox', '<div class="error">—</div>');
    setHTML('lastGameGoals', '');
    setHTML('standingLine', 'Standings position unavailable');
    setHTML('formLine', 'Last 5: —');
    setHTML('streakLine', 'Streak: —');
  }
})();
</script>

</body>
</html>
