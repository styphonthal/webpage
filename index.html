<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Buffalo Sabres — Scores & Goals</title>
<style>
  :root{
    --sabres-navy: #002654;
    --sabres-gold: #FCB514;
    --sabres-white: #f7f9fc;
    --bg-deep: #001631;
  }
  *{box-sizing:border-box; margin:0; padding:0}
  html,body{height:100%; min-height:100vh}
  body{
    color:var(--sabres-white);
    background:
      radial-gradient(1200px 700px at 80% 10%, rgba(252,181,20,.12), transparent 60%),
      radial-gradient(900px 500px at 20% 80%, rgba(0,38,84,.35), transparent 70%),
      var(--bg-deep);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
    padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  .wrap{
    max-width:1200px;
    width:100%;
    margin:0 auto;
    padding:28px clamp(16px, 3vw, 36px);
  }

  /* Team Header */
  .team-header{
    text-align:center;
    margin-bottom:24px;
    padding:20px;
    background: linear-gradient(180deg, rgba(0,38,84,.65), rgba(0,28,62,.65));
    border: 2px solid rgba(252,181,20,.25);
    border-radius:18px;
    box-shadow: 0 8px 24px rgba(0,0,0,.3);
  }

  /* NEW: header row w/ slug images */
  .team-header-row{
    display:grid;
    grid-template-columns: 72px 1fr 72px;
    align-items:center;
    gap:12px;
  }

  .slug{
    width:72px;
    height:auto;
    display:block;
    filter: drop-shadow(0 6px 14px rgba(0,0,0,.35));
    opacity:.95;
  }

  .slug.right{
    transform: scaleX(-1);
    justify-self:end;
  }

  .slug.left{
    justify-self:start;
  }

  .team-header h1{
    margin:0;
    font-size:2rem;
    color:var(--sabres-gold);
    font-weight:800;
    letter-spacing:.5px;
  }

  .team-stats{
    display:flex;
    justify-content:center;
    gap:32px;
    flex-wrap:wrap;
    margin-top:10px;
  }

  .stat-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:4px;
  }

  .stat-label{
    font-size:.9rem;
    color:#a8c5f5;
    font-weight:600;
    text-transform:uppercase;
    letter-spacing:.5px;
  }

  .stat-value{
    font-size:1.3rem;
    color:var(--sabres-gold);
    font-weight:700;
  }

  .top-scorer{
    margin-top:12px;
    padding-top:12px;
    border-top:1px solid rgba(252,181,20,.2);
    color:#cfe1ff;
    font-size:1.05rem;
  }

  .top-scorer strong{
    color:var(--sabres-gold);
    font-weight:700;
  }

  /* Score header */
  .scorebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:18px;
    flex-wrap:wrap;
    background: linear-gradient(180deg, rgba(0,38,84,.85), rgba(0,28,62,.85));
    border: 2px solid rgba(252,181,20,.35);
    border-radius:18px;
    padding:18px 20px;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
  }

  .teams{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center;
    gap:16px;
    flex:1 1 auto;
    min-width:0;
  }

  .team{
    display:flex;
    align-items:center;
    gap:12px;
    min-width:0;
  }

  .team.away{justify-content:flex-end}
  .team.home{justify-content:flex-start}

  .badge{
    width:50px;
    height:50px;
    border-radius:10px;
    background-size:contain;
    background-position:center;
    background-repeat:no-repeat;
    border:2px solid rgba(252,181,20,.3);
    flex-shrink:0;
  }

  .name{
    font-weight:700;
    letter-spacing:.3px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    font-size:1.1rem;
  }

  .score{
    font-weight:800;
    font-size:2.4rem;
    padding:0 12px;
    color:var(--sabres-gold);
    white-space:nowrap;
  }

  .meta{
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    gap:6px;
    min-width:160px;
    color:#cfe1ff;
  }

  .state{
    font-weight:700;
    font-size:1.05rem;
  }

  .pill{
    display:inline-block;
    font-size:.9rem;
    padding:5px 12px;
    border-radius:999px;
    background: rgba(252,181,20,.18);
    border:1px solid rgba(252,181,20,.35);
    color:#ffe9b3;
    font-weight:600;
  }

  /* Panels */
  .panel{
    margin-top:20px;
    background: linear-gradient(180deg, rgba(0,38,84,.72), rgba(0,28,62,.72));
    border: 1px solid rgba(252,181,20,.28);
    border-radius:16px;
    padding:18px 20px;
  }

  .panel h3{
    margin:0 0 14px 0;
    font-size:1.15rem;
    color:#ffe9b3;
    border-bottom:1px solid rgba(252,181,20,.2);
    padding-bottom:8px;
  }

  .game-summary{
    display:flex;
    flex-direction:column;
    gap:8px;
    font-size:1rem;
  }

  .game-summary strong{
    color:var(--sabres-gold);
  }

  /* Goals list */
  .goals{
    display:grid;
    gap:12px;
  }

  .goal{
    display:grid;
    grid-template-columns: 90px 1fr;
    gap:14px;
    align-items:start;
    padding:12px 14px;
    border-radius:12px;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(252,181,20,.15);
    transition:all .2s;
  }

  .goal:hover{
    background: rgba(252,181,20,.08);
    border-color:rgba(252,181,20,.3);
  }

  .time{
    font-weight:700;
    color:#ffe3a3;
    font-size:.95rem;
  }

  .goal-details{
    display:flex;
    flex-direction:column;
    gap:4px;
  }

  .who{
    font-weight:700;
    color:var(--sabres-white);
  }

  .team-name{
    color:var(--sabres-gold);
    font-weight:600;
  }

  .assist{
    color:#c6d6f6;
    font-size:.9rem;
    margin-top:2px;
  }

  .assist-player{
    display:inline-block;
    margin-right:8px;
  }

  .sep{
    opacity:.4;
    padding:0 6px;
  }

  .strength{
    color:#a8c5f5;
    font-size:.85rem;
  }

  .loading, .error, .info{
    text-align:center;
    padding:20px;
    color:#c6d6f6;
  }

  .error{ color:#ff9999; }

  .info{
    color:#a8c5f5;
    font-size:.95rem;
    line-height:1.6;
  }

  @media (max-width:768px){
    .teams{ grid-template-columns: 1fr; gap:12px; }
    .team{ justify-content:center !important; }
    .score{ text-align:center; font-size:2rem; }
    .meta{ align-items:center; min-width:auto; }
    .goal{ grid-template-columns:80px 1fr; gap:10px; }

    /* On small screens, hide slugs to save width */
    .team-header-row{ grid-template-columns: 1fr; }
    .slug{ display:none; }
  }

  @media (max-width:480px){
    .score{font-size:1.8rem}
    .name{font-size:1rem}
    .badge{width:40px; height:40px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Team Header -->
    <div class="team-header">
      <div class="team-header-row">
        <img class="slug left" src="slug.png" alt="Slug" />
        <h1>Buffalo Sabres</h1>
        <img class="slug right" src="slug.png" alt="Slug" />
      </div>

      <div class="team-stats">
        <div class="stat-item">
          <span class="stat-label">Record</span>
          <span class="stat-value" id="record">0-0-0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Points</span>
          <span class="stat-value" id="points">0</span>
        </div>
      </div>
      <div class="top-scorer" id="topScorer">
        Loading top scorer...
      </div>
    </div>

    <!-- Primary score bar -->
    <div class="scorebar" id="scorebar">
      <div class="teams">
        <div class="team away" id="awayTeam">
          <div class="name">Away</div>
          <div class="badge" id="awayBadge"></div>
        </div>
        <div class="score" id="score">0 — 0</div>
        <div class="team home" id="homeTeam">
          <div class="badge" id="homeBadge"></div>
          <div class="name">Home</div>
        </div>
      </div>
      <div class="meta">
        <div class="state" id="state">Loading…</div>
        <div><span class="pill" id="when"></span></div>
        <div class="muted" id="updated" style="font-size:.85rem; opacity:.75; margin-top:4px;"></div>
      </div>
    </div>

    <!-- Goals (MOVED: now directly below live scoring update) -->
    <div class="panel">
      <h3>Goals</h3>
      <div class="goals" id="goals"><div class="loading">Loading goals…</div></div>
    </div>

    <!-- Last Game -->
    <div class="panel" id="lastGamePanel">
      <h3>Last Game</h3>
      <div id="lastGameBox" class="loading">Loading…</div>
    </div>

    <!-- Next Game -->
    <div class="panel" id="nextGamePanel">
      <h3>Next Game</h3>
      <div id="nextGameBox" class="loading">Loading…</div>
    </div>
  </div>

<script>
(async function(){
  const SABRES_ABBR = 'BUF';
  const CORS_PROXY = 'https://corsproxy.io/?';

  // Refresh/backoff config
  const BASE_REFRESH_MS = 15000;
  const MAX_REFRESH_MS  = 120000;   // cap backoff at 2 minutes
  const MAX_CONSEC_FAIL = 8;        // stop after N consecutive failures
  const SCHEDULE_RECHECK_EVERY = 8; // every 8 ticks (~2 minutes at 15s) re-check schedule

  let refreshTimer = null;
  let currentGameId = null;
  let currentPrimaryGame = null;
  let tickCount = 0;
  let consecutiveFailures = 0;
  let currentDelay = BASE_REFRESH_MS;

  // Helper functions
  const setTxt = (id, t) => {
    const el = document.getElementById(id);
    if (el) el.textContent = t;
  };

  const setHTML = (id, html) => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  };

  function formatDate(dateStr) {
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        timeZone: 'America/New_York',
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    } catch {
      return dateStr;
    }
  }

  function nyYYYYMMDD(d) {
    const y = d.toLocaleString('en-CA', { timeZone: 'America/New_York', year: 'numeric' });
    const m = d.toLocaleString('en-CA', { timeZone: 'America/New_York', month: '2-digit' });
    const day = d.toLocaleString('en-CA', { timeZone: 'America/New_York', day: '2-digit' });
    return `${y}-${m}-${day}`;
  }

  function getTeamLogo(abbr) {
    return `https://assets.nhle.com/logos/nhl/svg/${abbr}_light.svg`;
  }

  function teamLabel(t) {
    return t?.placeName?.default
        || t?.commonName?.default
        || t?.name?.default
        || t?.abbrev
        || '';
  }

  function setUpdatedNow(extraNote = '') {
    const el = document.getElementById('updated');
    if (!el) return;
    const ts = new Date().toLocaleTimeString('en-US', {
      timeZone: 'America/New_York',
      hour: 'numeric',
      minute: '2-digit',
      second: '2-digit'
    });
    el.textContent = `Updated ${ts}${extraNote ? ` • ${extraNote}` : ''}`;
  }

  // Cache buster on ALL NHL endpoints
  function withCacheBuster(url) {
    try {
      const u = new URL(url);
      u.searchParams.set('cb', String(Date.now()));
      return u.toString();
    } catch {
      const sep = url.includes('?') ? '&' : '?';
      return `${url}${sep}cb=${Date.now()}`;
    }
  }

  async function fetchJSON(url) {
    try {
      const busted = withCacheBuster(url);
      const proxiedUrl = CORS_PROXY + encodeURIComponent(busted);
      const response = await fetch(proxiedUrl, { cache: 'no-store' });
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return await response.json();
    } catch (error) {
      console.error('Fetch error:', url, error);
      throw error;
    }
  }

  // Get team standings and stats
  async function getTeamStats() {
    try {
      const url = `https://api-web.nhle.com/v1/standings/now`;
      const data = await fetchJSON(url);

      let sabres = null;
      for (const standing of data.standings || []) {
        if (standing.teamAbbrev?.default === SABRES_ABBR) {
          sabres = standing;
          break;
        }
      }

      if (!sabres) {
        console.log('Sabres not found in standings, trying team common name...');
        return { wins: 0, losses: 0, otLosses: 0, points: 0 };
      }

      return {
        wins: sabres.wins || 0,
        losses: sabres.losses || 0,
        otLosses: sabres.otLosses || 0,
        points: sabres.points || 0
      };
    } catch (error) {
      console.error('Error fetching team stats:', error);
      return null;
    }
  }

  // Get roster and find top scorer
  async function getTopScorer() {
    try {
      const url = `https://api-web.nhle.com/v1/club-stats/${SABRES_ABBR}/now`;
      const data = await fetchJSON(url);

      const skaters = data.skaters || [];
      if (skaters.length === 0) {
        console.log('No skaters found');
        return null;
      }

      const topScorer = skaters.reduce((top, player) => {
        const goals = player.goals || 0;
        return goals > (top.goals || 0) ? player : top;
      }, skaters[0]);

      return {
        name: `${topScorer.firstName?.default || ''} ${topScorer.lastName?.default || ''}`.trim(),
        goals: topScorer.goals || 0
      };
    } catch (error) {
      console.error('Error fetching top scorer:', error);
      return null;
    }
  }

  // Schedule week selection NY-time based
  async function getSchedule() {
    const now = new Date();
    const nowNY = nyYYYYMMDD(now);

    const url = `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${nowNY}`;
    const data = await fetchJSON(url);

    const prevWeek = new Date(now);
    prevWeek.setDate(prevWeek.getDate() - 7);
    const prevNY = nyYYYYMMDD(prevWeek);

    const prevUrl = `https://api-web.nhle.com/v1/club-schedule/${SABRES_ABBR}/week/${prevNY}`;
    const prevData = await fetchJSON(prevUrl);

    const allGames = [...(prevData.games || []), ...(data.games || [])];

    const liveGame = allGames.find(g =>
      g.gameState === 'LIVE' ||
      g.gameState === 'CRIT' ||
      g.gameState === 'CRITICAL'
    );

    const lastGame = allGames
      .filter(g => (g.gameState === 'OFF' || g.gameState === 'FINAL') && g.id !== liveGame?.id)
      .sort((a, b) => new Date(b.startTimeUTC) - new Date(a.startTimeUTC))[0];

    const nextGame = allGames
      .filter(g => g.gameState === 'FUT' || g.gameState === 'PRE')
      .sort((a, b) => new Date(a.startTimeUTC) - new Date(b.startTimeUTC))[0];

    return { liveGame, lastGame, nextGame, games: allGames };
  }

  // Game details
  async function getGameDetails(gameId) {
    const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/play-by-play`;
    return await fetchJSON(url);
  }

  // Intermission time extraction
  function parseClockMMSS(s) {
    if (!s || typeof s !== 'string') return null;
    const m = s.match(/^(\d{1,2}):(\d{2})$/);
    if (!m) return null;
    const mm = parseInt(m[1], 10);
    const ss = parseInt(m[2], 10);
    if (!Number.isFinite(mm) || !Number.isFinite(ss)) return null;
    return { mm, ss, total: mm * 60 + ss };
  }

  function formatSecondsToMMSS(sec) {
    if (!Number.isFinite(sec)) return '';
    const s = Math.max(0, Math.floor(sec));
    const mm = Math.floor(s / 60);
    const ss = String(s % 60).padStart(2, '0');
    return `${mm}:${ss}`;
  }

  function getIntermissionDisplay(clock) {
    if (!clock) return '';

    const tr = typeof clock.timeRemaining === 'string' ? clock.timeRemaining.trim() : '';

    const candidates = [
      clock.intermissionTimeRemaining,
      clock.intermissionRemaining,
      clock.intermissionTimeRemainingSeconds,
      clock.intermissionRemainingSeconds,
      clock.intermissionTimeRemainingSec,
      clock.intermissionRemainingSec,
      clock.intermissionTimeLeft,
      clock.intermissionTimeLeftSeconds,
      clock.intermissionClock
    ];

    for (const c of candidates) {
      if (typeof c === 'string' && parseClockMMSS(c)) {
        return `INT ${c}`;
      }
    }

    for (const c of candidates) {
      if (typeof c === 'number' && Number.isFinite(c)) {
        return `INT ${formatSecondsToMMSS(c)}`;
      }
    }

    if (parseClockMMSS(tr)) {
      return `INT ${tr}`;
    }

    return 'Intermission';
  }

  // Render scorebar
  function renderScorebar(game, details, isLive = false) {
    if (!game) {
      setTxt('state', 'No game data');
      setTxt('when', '—');
      return;
    }

    const away = details?.awayTeam || game.awayTeam;
    const home = details?.homeTeam || game.homeTeam;

    document.querySelector('#awayTeam .name').textContent = teamLabel(away);
    document.querySelector('#homeTeam .name').textContent = teamLabel(home);

    const awayAbbrev = away.abbrev || game.awayTeam?.abbrev;
    const homeAbbrev = home.abbrev || game.homeTeam?.abbrev;

    document.getElementById('awayBadge').style.backgroundImage =
      `url('${getTeamLogo(awayAbbrev)}')`;
    document.getElementById('homeBadge').style.backgroundImage =
      `url('${getTeamLogo(homeAbbrev)}')`;

    const awayScore = details?.awayTeam?.score ?? game.awayTeam?.score ?? 0;
    const homeScore = details?.homeTeam?.score ?? game.homeTeam?.score ?? 0;
    setTxt('score', `${awayScore} — ${homeScore}`);

    const gameState = details?.gameState || game.gameState;
    const isActuallyLive = ['LIVE', 'CRIT', 'CRITICAL'].includes(gameState);

    let status = 'Final';
    if (isActuallyLive) {
      status = 'LIVE';

      if (details?.periodDescriptor) {
        const period = details.periodDescriptor.number;
        const periodType = details.periodDescriptor.periodType;
        if (periodType === 'OT') {
          status = 'OVERTIME';
        } else if (periodType === 'SO') {
          status = 'SHOOTOUT';
        } else {
          status = `${period}${period === 1 ? 'st' : period === 2 ? 'nd' : period === 3 ? 'rd' : 'th'} Period`;
        }
      }

      if (details?.clock?.inIntermission) {
        status = 'Intermission';
      }
    } else if (['FUT', 'PRE'].includes(gameState)) {
      status = 'Scheduled';
    } else if (['FINAL', 'OFF'].includes(gameState)) {
      status = 'Final';
    }

    setTxt('state', status);

    let when = '';
    if (isActuallyLive) {
      if (details?.clock?.inIntermission) {
        when = getIntermissionDisplay(details.clock);
      } else {
        when = details?.clock?.timeRemaining || '';
      }
    } else {
      when = formatDate(game.startTimeUTC);
    }

    setTxt('when', when || '—');
  }

  // Roster mapping (merged candidates)
  function gatherRosterCandidates(details) {
    const out = [];
    const maybePush = (arr) => { if (Array.isArray(arr)) out.push(...arr); };

    maybePush(details?.rosterSpots);
    maybePush(details?.players);
    maybePush(details?.playerSpots);
    maybePush(details?.skaters);
    maybePush(details?.goalies);

    maybePush(details?.homeTeam?.rosterSpots);
    maybePush(details?.awayTeam?.rosterSpots);
    maybePush(details?.homeTeam?.players);
    maybePush(details?.awayTeam?.players);

    return out;
  }

  function buildPlayerMap(details) {
    const playerMap = new Map();
    const roster = gatherRosterCandidates(details);

    for (const p of roster) {
      const pid = p?.playerId ?? p?.id;
      if (!pid) continue;

      const fn = (typeof p?.firstName === 'string') ? p.firstName : (p?.firstName?.default || '');
      const ln = (typeof p?.lastName === 'string')  ? p.lastName  : (p?.lastName?.default  || '');
      const name = `${fn} ${ln}`.trim();
      if (name) playerMap.set(pid, name);
    }

    return playerMap;
  }

  // Goal helpers
  function timeToSeconds(t) {
    const parsed = parseClockMMSS(t);
    if (!parsed) return null;
    return parsed.total;
  }

  function isShootoutGoal(play) {
    const pt = play?.periodDescriptor?.periodType;
    if (pt === 'SO') return true;

    if (play?.details?.isShootout === true) return true;
    if (play?.details?.shootout === true) return true;
    if (play?.details?.situationCode === 'SO') return true;

    return false;
  }

  // Render goals (NEWEST ON TOP)
  function renderGoals(details) {
    const goalsEl = document.getElementById('goals');

    if (!details) {
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const plays = details.plays || details.gameEvents || [];
    if (!plays || plays.length === 0) {
      console.log('Available detail keys:', Object.keys(details));
      goalsEl.innerHTML = '<div class="loading">No play data available</div>';
      return;
    }

    const playerMap = buildPlayerMap(details);

    let goals = plays
      .filter(play => play.typeDescKey === 'goal' || play.typeCode === 'GOAL')
      .filter(play => !isShootoutGoal(play));

    if (goals.length === 0) {
      goalsEl.innerHTML = '<div class="loading">No goals scored yet</div>';
      return;
    }

    // Sort newest-first: period desc, time desc, then stable by original order desc
    goals = goals
      .map((g, idx) => ({ g, idx }))
      .sort((A, B) => {
        const a = A.g, b = B.g;

        const ap = a?.periodDescriptor?.number ?? 0;
        const bp = b?.periodDescriptor?.number ?? 0;
        if (ap !== bp) return bp - ap;

        const ats = timeToSeconds(a?.timeInPeriod);
        const bts = timeToSeconds(b?.timeInPeriod);

        if (ats == null || bts == null) return B.idx - A.idx;
        if (ats !== bts) return bts - ats;

        return B.idx - A.idx;
      })
      .map(x => x.g);

    let html = '';
    for (const goal of goals) {
      const period = goal.periodDescriptor?.number || '';
      const time = goal.timeInPeriod || '';
      const teamId = goal.details?.eventOwnerTeamId;

      const teamInfo = (details.homeTeam?.id === teamId) ? details.homeTeam : details.awayTeam;
      const teamName = teamLabel(teamInfo);

      let scorerName = 'Unknown';
      let goalNumber = '';

      if (goal.details) {
        const scorerId = goal.details.scoringPlayerId || goal.details.playerId;

        if (scorerId && playerMap.has(scorerId)) {
          scorerName = playerMap.get(scorerId);
        } else if (goal.details.scoringPlayer) {
          scorerName = goal.details.scoringPlayer;
        }

        if (goal.details.scoringPlayerTotal) {
          goalNumber = ` (${goal.details.scoringPlayerTotal})`;
        }
      }

      const assists = [];
      if (goal.details) {
        const assist1Id = goal.details.assist1PlayerId;
        if (assist1Id && playerMap.has(assist1Id)) {
          const total = goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : '';
          assists.push(`${playerMap.get(assist1Id)}${total}`);
        } else if (goal.details.assist1Player) {
          const total = goal.details.assist1PlayerTotal ? ` (${goal.details.assist1PlayerTotal})` : '';
          assists.push(`${goal.details.assist1Player}${total}`);
        }

        const assist2Id = goal.details.assist2PlayerId;
        if (assist2Id && playerMap.has(assist2Id)) {
          const total = goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : '';
          assists.push(`${playerMap.get(assist2Id)}${total}`);
        } else if (goal.details.assist2Player) {
          const total = goal.details.assist2PlayerTotal ? ` (${goal.details.assist2PlayerTotal})` : '';
          assists.push(`${goal.details.assist2Player}${total}`);
        }
      }

      const strength = goal.details?.strength || 'ev';
      const situation = goal.details?.situationCode || '';

      html += `
        <div class="goal">
          <div class="time">Period ${period}<br>${time}</div>
          <div class="goal-details">
            <div>
              <span class="team-name">${teamName}</span>
              <span class="sep">—</span>
              <span class="who">${scorerName}${goalNumber}</span>
            </div>
            <div class="strength">${String(strength).toUpperCase()}${situation ? ` (${situation})` : ''}</div>
            ${assists.length ? `
              <div class="assist">Assists: ${assists.map(a => `<span class="assist-player">${a}</span>`).join('')}</div>
            ` : ''}
          </div>
        </div>
      `;
    }

    goalsEl.innerHTML = html;
  }

  // Render last game summary
  function renderLastGame(game) {
    const el = document.getElementById('lastGameBox');
    if (!game) {
      el.innerHTML = '<div class="loading">No previous game data</div>';
      return;
    }

    const away = game.awayTeam;
    const home = game.homeTeam;
    const when = formatDate(game.startTimeUTC);

    el.innerHTML = `
      <div class="game-summary">
        <div><strong>${teamLabel(away)}</strong> at <strong>${teamLabel(home)}</strong></div>
        <div>Final: ${away.score || 0} — ${home.score || 0}</div>
        <div>${when}</div>
      </div>
    `;
  }

  // Render next game summary
  function renderNextGame(game) {
    const el = document.getElementById('nextGameBox');
    if (!game) {
      el.innerHTML = '<div class="loading">No upcoming game scheduled</div>';
      return;
    }

    const away = game.awayTeam;
    const home = game.homeTeam;
    const when = formatDate(game.startTimeUTC);

    el.innerHTML = `
      <div class="game-summary">
        <div><strong>${teamLabel(away)}</strong> at <strong>${teamLabel(home)}</strong></div>
        <div>${when}</div>
      </div>
    `;
  }

  // Refresh loop utilities
  function clearRefreshTimer() {
    if (refreshTimer) {
      clearTimeout(refreshTimer);
      refreshTimer = null;
    }
  }

  function scheduleNextTick(delayMs) {
    clearRefreshTimer();
    refreshTimer = setTimeout(refreshTick, delayMs);
  }

  async function refreshTick() {
    if (document.hidden) {
      scheduleNextTick(Math.min(currentDelay, 30000));
      return;
    }

    if (!currentGameId || !currentPrimaryGame) return;

    try {
      tickCount++;

      if (tickCount % SCHEDULE_RECHECK_EVERY === 0) {
        const sch = await getSchedule();
        renderLastGame(sch.lastGame);
        renderNextGame(sch.nextGame);

        if (!sch.liveGame) {
          setUpdatedNow('Schedule: no live game');
          location.reload();
          return;
        }

        if (sch.liveGame.id && sch.liveGame.id !== currentGameId) {
          currentGameId = sch.liveGame.id;
          currentPrimaryGame = sch.liveGame;
          setUpdatedNow('Switched live game');
        }
      }

      const updatedDetails = await getGameDetails(currentGameId);
      const gameState = updatedDetails?.gameState;

      renderScorebar(currentPrimaryGame, updatedDetails, true);
      renderGoals(updatedDetails);
      setUpdatedNow();

      consecutiveFailures = 0;
      currentDelay = BASE_REFRESH_MS;

      if (['FINAL', 'OFF'].includes(gameState)) {
        setUpdatedNow('Final');
        clearRefreshTimer();
        setTimeout(() => location.reload(), 2000);
        return;
      }

      scheduleNextTick(currentDelay);
    } catch (e) {
      consecutiveFailures++;
      console.error('Refresh error:', e);

      currentDelay = Math.min(MAX_REFRESH_MS, Math.floor(currentDelay * 2));
      setUpdatedNow(`Delayed (x${consecutiveFailures})`);

      if (consecutiveFailures >= MAX_CONSEC_FAIL) {
        clearRefreshTimer();
        setTxt('state', 'Data delayed');
        setTxt('when', '—');
        setHTML('goals',
          `<div class="error">Live updates paused after repeated failures (likely proxy throttling). Reload to resume.</div>`
        );
        return;
      }

      scheduleNextTick(currentDelay);
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      if (currentGameId && currentPrimaryGame) {
        scheduleNextTick(250);
      }
    }
  });

  // Main execution
  try {
    const schedule = await getSchedule();

    let teamStats = null;
    let topScorer = null;

    try { teamStats = await getTeamStats(); }
    catch (e) { console.error('Failed to load team stats:', e); }

    try { topScorer = await getTopScorer(); }
    catch (e) { console.error('Failed to load top scorer:', e); }

    if (teamStats) {
      setTxt('record', `${teamStats.wins}-${teamStats.losses}-${teamStats.otLosses}`);
      setTxt('points', String(teamStats.points));
    } else {
      setHTML('record', '<span style="font-size:.9rem">Loading...</span>');
      setHTML('points', '<span style="font-size:.9rem">...</span>');
    }

    if (topScorer) {
      setHTML('topScorer', `Current leading scorer: <strong>${topScorer.name}</strong>, ${topScorer.goals} goals`);
    } else {
      setHTML('topScorer', 'Top scorer unavailable');
    }

    const primaryGame = schedule.liveGame || schedule.lastGame;
    const isLive = !!schedule.liveGame;

    if (primaryGame) {
      currentPrimaryGame = primaryGame;
      currentGameId = primaryGame.id;

      const details = await getGameDetails(primaryGame.id);
      renderScorebar(primaryGame, details, isLive);
      renderGoals(details);
      setUpdatedNow();

      if (isLive) {
        tickCount = 0;
        consecutiveFailures = 0;
        currentDelay = BASE_REFRESH_MS;
        scheduleNextTick(BASE_REFRESH_MS);
      }
    } else {
      setTxt('state', 'No recent game');
      setTxt('score', '— — —');
      setTxt('when', '—');
      setHTML('goals', '<div class="info">No recent games found. Check back during the hockey season!</div>');
      setUpdatedNow();
    }

    renderLastGame(schedule.lastGame);
    renderNextGame(schedule.nextGame);

  } catch (error) {
    console.error('Error loading data:', error);
    setTxt('state', 'Error loading data');
    setHTML('goals', `<div class="error">Unable to load NHL data. This widget uses a CORS proxy which may be rate-limited. Please try again in a few moments.</div>`);
    setHTML('lastGameBox', '<div class="error">—</div>');
    setHTML('nextGameBox', '<div class="error">—</div>');
    setUpdatedNow('Error');
  }
})();
</script>

</body>
</html>
